-- POR USUARIO
CREATE TABLE TIPO_CLIENTE (
    id_tipo_cliente INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY,
    nombre VARCHAR2(50)
        UNIQUE
        NOT NULL,
    descripcion VARCHAR2(100)
        NOT NULL
    CONSTRAINT chk_descripcion CHECK (REGEXP_LIKE(descripcion, '^[A-Za-zÁÉÍÓÚáéíóúÑñÜü ]+$')),
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL
);


CREATE TABLE CLIENTE (
    id_cliente INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    nombre VARCHAR2(50)
        CONSTRAINT chk_nombre CHECK (REGEXP_LIKE(nombre, '^[A-Za-zÁÉÍÓÚáéíóúÑñÜü ]+$'))
        NOT NULL,
    apellido VARCHAR2(50)
        CONSTRAINT chk_apellido CHECK (REGEXP_LIKE(apellido, '^[A-Za-zÁÉÍÓÚáéíóúÑñÜü ]+$'))
        NOT NULL,
    numero_telefono VARCHAR2(12) NOT NULL,
    email VARCHAR2(50) NOT NULL,
    usuario VARCHAR2(50) NOT NULL UNIQUE,
    contrasena VARCHAR2(100) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    tipo_cliente INTEGER NOT NULL,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    CONSTRAINT fk_tipo_cliente 
        FOREIGN KEY (tipo_cliente) 
        REFERENCES TIPO_CLIENTE(id_tipo_cliente)
);


CREATE TABLE TIPO_CUENTA (
    id_tipo_cuenta INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    nombre VARCHAR2(50)
        UNIQUE
        NOT NULL,
    descripcion VARCHAR2(100)
        CONSTRAINT chk_descripcion_tipo_cuenta CHECK (REGEXP_LIKE(descripcion, '^[A-Za-zÁÉÍÓÚáéíóúÑñÜü ]+$'))
        NOT NULL,
    interes NUMBER(5,2)
        CONSTRAINT chk_interes_positivo CHECK (interes >= 0)
        NOT NULL,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL
);


CREATE TABLE CUENTA (
    id_cuenta INTEGER 
        GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1)  
        PRIMARY KEY
        NOT NULL,
    id_cliente INTEGER NOT NULL,
    monto_apertura NUMBER(12,2)
        CONSTRAINT chk_monto_positivo_cuenta CHECK (monto_apertura > 0)
        NOT NULL,
    saldo_cuenta NUMBER(12,2)
        CONSTRAINT chk_saldo_no_negativo_cuenta CHECK (saldo_cuenta >= 0)
        NOT NULL,
    fecha_apertura DATE
        DEFAULT SYSDATE
        NOT NULL,
    fecha_ultimo_interes DATE,
    tipo_cuenta INTEGER NOT NULL,
    descripcion VARCHAR2(75) NOT NULL,
    otros_detalles VARCHAR2(100),
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    CONSTRAINT fk_id_cliente
        FOREIGN KEY (id_cliente) 
        REFERENCES CLIENTE(id_cliente),
    CONSTRAINT fk_tipo_cuenta
        FOREIGN KEY (tipo_cuenta)
        REFERENCES TIPO_CUENTA(id_tipo_cuenta)
);


CREATE TABLE INTERES_CUENTA (
    id_interes INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    id_cuenta INTEGER NOT NULL,
    fecha_calculo DATE NOT NULL,
    monto_interes NUMBER(12,2) NOT NULL,
    periodo_inicio DATE NOT NULL,
    periodo_fin DATE NOT NULL,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    CONSTRAINT fk_interes_cuenta
        FOREIGN KEY (id_cuenta)
        REFERENCES CUENTA(id_cuenta)
);

CREATE TABLE NOTIFICACION (
    id_notificacion INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    id_cliente INTEGER NOT NULL,
    mensaje VARCHAR2(255) NOT NULL,
    fecha TIMESTAMP NOT NULL,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    CONSTRAINT fk_id_cliente_notificacion
        FOREIGN KEY (id_cliente) REFERENCES CLIENTE(id_cliente)
);

CREATE TABLE TIPO_TARJETA (
    id_tipo_tarjeta INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    nombre VARCHAR2(50) NOT NULL UNIQUE,
    descripcion VARCHAR2(100) NOT NULL
        CONSTRAINT chk_descripcion_tarjeta
        CHECK (REGEXP_LIKE(descripcion, '^[A-Za-zÁÉÍÓÚáéíóúÑñÜü ]+$')),
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL
);


INSERT INTO TIPO_TARJETA (nombre, descripcion) VALUES ('Tarjeta basica', 'Tarjeta de uso general');
INSERT INTO TIPO_TARJETA (nombre, descripcion) VALUES ('Tarjeta premium', 'Tarjeta de uso premium');
INSERT INTO TIPO_TARJETA (nombre, descripcion) VALUES ('Tarjeta black', 'Tarjeta de uso exclusivo');
commit;

CREATE TABLE TARJETA (
    id_tarjeta INTEGER 
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1) 
        PRIMARY KEY
        NOT NULL,
    id_cliente INTEGER NOT NULL,
    id_cuenta INTEGER,
    id_tipo_tarjeta INTEGER NOT NULL,
    id_tipo VARCHAR2(1) NOT NULL
        CONSTRAINT chk_tipo_tarjeta_t
        CHECK (id_tipo IN ('C', 'D')),
    numero_tarjeta Number(16,0) UNIQUE NOT NULL ,
    moneda VARCHAR2(1) NOT NULL
        CONSTRAINT chk_moneda_tarjeta_t
        CHECK (Moneda IN ('Q', '$')),
    monto_limite NUMBER(12,2)
        NOT NULL
        CONSTRAINT chk_monto_positivo_tarjeta
        CHECK (monto_limite > 0),
    saldo_tarjeta NUMBER(12,2)
        NOT NULL
        CONSTRAINT chk_saldo_no_negativo_tarjeta
        CHECK (saldo_tarjeta >= 0),
    dia_corte INTEGER NOT NULL
        CONSTRAINT chk_dia_corte_tarjeta
        CHECK (dia_corte BETWEEN 1 AND 31),
    dia_pago INTEGER NOT NULL
        CONSTRAINT chk_dia_pago_tarjeta
        CHECK (dia_pago BETWEEN 1 AND 31),
    tasa_interes INTEGER NOT NULL
        CONSTRAINT chk_tasa_interes_tarjeta
        CHECK (tasa_interes BETWEEN 0 AND 100),
    fecha_vencimiento DATE NOT NULL,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    fecha_ultimo_interes DATE,
    CONSTRAINT fk_id_cliente_tarjeta
        FOREIGN KEY (id_cliente) 
        REFERENCES CLIENTE(id_cliente),
    CONSTRAINT fk_id_cuenta_tarjeta
        FOREIGN KEY (id_cuenta) 
        REFERENCES CUENTA(id_cuenta),
    CONSTRAINT fk_id_tipo_tarjeta_tarjeta
        FOREIGN KEY (id_tipo_tarjeta) 
        REFERENCES TIPO_TARJETA(id_tipo_tarjeta)
);

CREATE TABLE MOVIMIENTO_TARJETA (
    id_movimiento INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    id_tarjeta INTEGER NOT NULL,
    fecha_movimiento TIMESTAMP NOT NULL,
    monto NUMBER(12,2) NOT NULL 
        CONSTRAINT chk_monto_positivo
        CHECK (monto > 0),
    descripcion VARCHAR2(100) NOT NULL,
    tipo VARCHAR2(1) NOT NULL
        CONSTRAINT chk_tipo_movimiento
        CHECK (tipo IN ('C', 'D')), -- C: Pago, D: Consumo/Interés
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    CONSTRAINT fk_movimiento_tarjeta
        FOREIGN KEY (id_tarjeta)
        REFERENCES TARJETA(id_tarjeta)
);


CREATE TABLE PREMIO (
    id_premio INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    id_cliente INTEGER NOT NULL,
    id_tarjeta INTEGER NOT NULL,
    premio NUMBER(12,2) NOT NULL
        CONSTRAINT chk_monto_positivo_premio
        CHECK (premio > 0),
    fecha TIMESTAMP NOT NULL,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    CONSTRAINT fk_id_cliente_premio
        FOREIGN KEY (id_cliente) REFERENCES CLIENTE(id_cliente),
    CONSTRAINT fk_id_tarjeta_premio
        FOREIGN KEY (id_tarjeta) REFERENCES TARJETA(id_tarjeta)
);


CREATE TABLE PRESTAMO (
    id_prestamo INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    id_cliente INTEGER NOT NULL,
    monto_prestamo NUMBER(12,2) NOT NULL
        CONSTRAINT chk_monto_positivo_prestamo
        CHECK (monto_prestamo > 0),
    tasa_interes INTEGER NOT NULL
        CONSTRAINT chk_tasa_interes_positivo_prestamo
        CHECK (tasa_interes >= 0),
    meses INTEGER NOT NULL
        CONSTRAINT chk_meses_positivo
        CHECK (meses > 0),
    monto_restante NUMBER(12,2) NOT NULL
        CONSTRAINT chk_monto_restante_positivo_prestamo
        CHECK (monto_restante > 0),
    meses_restantes INTEGER NOT NULL
        CONSTRAINT chk_meses_restantes_positivo_prestamo
        CHECK (meses_restantes > 0),
    fecha_contratacion DATE DEFAULT SYSDATE NOT NULL,
    fecha_vencimiento DATE NOT NULL,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    CONSTRAINT fk_cliente_prestamo
        FOREIGN KEY (id_cliente)
        REFERENCES CLIENTE(id_cliente)
);

CREATE TABLE CUOTA_PRESTAMO (
    id_cuota INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    id_prestamo INTEGER NOT NULL,
    numero_cuota INTEGER NOT NULL,
    fecha_vencimiento DATE NOT NULL,
    monto_cuota NUMBER(12,2) NOT NULL,
    capital NUMBER(12,2) NOT NULL,
    interes NUMBER(12,2) NOT NULL,
    saldo_restante NUMBER(12,2) NOT NULL,
    estado VARCHAR2(20) DEFAULT 'PENDIENTE' NOT NULL
        CONSTRAINT chk_estado_cuota_prestamo
        CHECK (estado IN ('PENDIENTE', 'PAGADA', 'VENCIDA', 'MORA')),
    fecha_pago DATE,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    CONSTRAINT fk_prestamo_cuota
        FOREIGN KEY (id_prestamo)
        REFERENCES PRESTAMO(id_prestamo)
);

CREATE TABLE TIPO_PAGO (
    id_tipo_producto INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    nombre VARCHAR2(50) UNIQUE NOT NULL,
    tipo INTEGER NOT NULL,
    monto_quetzales NUMBER(12,2) 
        CONSTRAINT chk_monto_positivo_quetzales_producto
        CHECK (monto_quetzales > 0),
    monto_dolares NUMBER(12,2) 
        CONSTRAINT chk_monto_positivo_dolares_producto
        CHECK (monto_dolares > 0),
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL
); 

INSERT INTO TIPO_PAGO (nombre, tipo) VALUES ('Pago de energía eléctrica (EEGSA)', 1);
INSERT INTO TIPO_PAGO (nombre, tipo) VALUES ('Pago de agua potable (EMPAGUA)', 1);
INSERT INTO TIPO_PAGO (nombre, tipo) VALUES ('Pago de Matrícula USAC', 1);
INSERT INTO TIPO_PAGO (nombre, tipo) VALUES ('Pago de curso de vacaciones USAC', 1);
INSERT INTO TIPO_PAGO (nombre, tipo) VALUES ('Pago de seguro', 1);
INSERT INTO TIPO_PAGO (nombre, tipo) VALUES ('Pago de tarjeta', 1);
INSERT INTO TIPO_PAGO (nombre, tipo) VALUES ('Pago de préstamo', 1);
INSERT INTO TIPO_PAGO (nombre, tipo, monto_quetzales, monto_dolares) VALUES ('Servicio de tarjeta de débito', 2, 10.00, 1.50);
INSERT INTO TIPO_PAGO (nombre, tipo, monto_quetzales, monto_dolares) VALUES ('Servicio de tarjeta de crédito', 2, 40.00, 5.00);
INSERT INTO TIPO_PAGO (nombre, tipo, monto_quetzales, monto_dolares) VALUES ('Servicio de cuenta de chequera', 2, 50.00, 6.25); 
commit;

CREATE TABLE TIPO_SEGURO (
    id_tipo_seguro INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    nombre VARCHAR2(50) UNIQUE NOT NULL,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL
);

INSERT INTO TIPO_SEGURO (nombre) VALUES ('Seguro de vida');
INSERT INTO TIPO_SEGURO (nombre) VALUES ('Seguro de automóvil');
INSERT INTO TIPO_SEGURO (nombre) VALUES ('Tarjeta medico');
INSERT INTO TIPO_SEGURO (nombre) VALUES ('Seguro de moto');
commit;

CREATE TABLE SEGURO (
    id_seguro INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    id_tipo_seguro INTEGER NOT NULL,
    id_cliente INTEGER NOT NULL,
    monto_asegurado NUMBER(12,2) NOT NULL
        CONSTRAINT chk_monto_positivo_segurom
        CHECK (monto_asegurado > 0),
    valor_seguro NUMBER(12,2) NOT NULL
        CONSTRAINT chk_monto_positivo_segurov
        CHECK (valor_seguro > 0),
    cantidad_pagos INTEGER NOT NULL
        CONSTRAINT chk_cantidad_pagos_positivo_seguro
        CHECK (cantidad_pagos > 0),
    meses_asegurados INTEGER NOT NULL
        CONSTRAINT chk_meses_asegurados_positivo_seguro
        CHECK (meses_asegurados > 0),
    fecha_contratacion TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    fecha_vencimiento TIMESTAMP NOT NULL,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    CONSTRAINT fk_id_tipo_seguro_seguro
        FOREIGN KEY (id_tipo_seguro) 
        REFERENCES TIPO_SEGURO(id_tipo_seguro),
    CONSTRAINT fk_id_cliente_seguro
        FOREIGN KEY (id_cliente) 
        REFERENCES CLIENTE(id_cliente)
);

CREATE TABLE PAGO_PRODUCTO_SERVICIO (
    id_pago_producto_servicio INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    id_tipo_pago INTEGER NOT NULL,
    tipo_pago INTEGER NOT NULL,
    id_tarjeta INTEGER,
    id_cliente INTEGER,
    id_cuenta INTEGER,
    id_prestamo INTEGER,
    id_seguro INTEGER,
    id_pago_tarjeta INTEGER,
    descripcion VARCHAR2(100) NOT NULL,
    monto NUMBER(12,2) NOT NULL 
        CONSTRAINT chk_monto_positivo_pago
        CHECK (monto > 0),
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    CONSTRAINT fk_id_tipo_pago_pago
        FOREIGN KEY (id_tipo_pago) 
        REFERENCES TIPO_PAGO(id_tipo_producto),
    CONSTRAINT fk_id_tarjeta_pago
        FOREIGN KEY (id_tarjeta) 
        REFERENCES TARJETA(id_tarjeta),
    CONSTRAINT fk_id_cuenta_pago
        FOREIGN KEY (id_cuenta) 
        REFERENCES CUENTA(id_cuenta),
    CONSTRAINT fk_id_prestamo_pago
        FOREIGN KEY (id_prestamo) 
        REFERENCES PRESTAMO(id_prestamo),
    CONSTRAINT fk_id_seguro_pago
        FOREIGN KEY (id_seguro) 
        REFERENCES SEGURO(id_seguro),
    CONSTRAINT fk_id_pago_tarjeta_pago
        FOREIGN KEY (id_pago_tarjeta) 
        REFERENCES TARJETA(id_tarjeta),
    CONSTRAINT fk_id_cliente_pago
        FOREIGN KEY (id_cliente) 
        REFERENCES CLIENTE(id_cliente)
);


CREATE TABLE EMPRESA_REMESA (
    id_empresa_remesa INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    nombre VARCHAR2(50) UNIQUE NOT NULL,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL
);


INSERT INTO EMPRESA_REMESA (nombre) VALUES ('MoneyGram');
INSERT INTO EMPRESA_REMESA (nombre) VALUES ('Intermex');
commit;

CREATE TABLE REMESA (
    id_remesa INTEGER 
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)  
        PRIMARY KEY
        NOT NULL,
    id_empresa_remesa INTEGER NOT NULL,
    monto NUMBER(12,2) NOT NULL
        CONSTRAINT chk_monto_positivo_remesa
        CHECK (monto > 0),
    fecha TIMESTAMP NOT NULL,
    pais VARCHAR2(5) NOT NULL,
    id_cliente INTEGER NOT NULL,
    id_cuenta INTEGER NOT NULL,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    CONSTRAINT fk_id_empresa_remesa
        FOREIGN KEY (id_empresa_remesa) 
        REFERENCES EMPRESA_REMESA(id_empresa_remesa),
    CONSTRAINT fk_id_cliente_remesa
        FOREIGN KEY (id_cliente) 
        REFERENCES CLIENTE(id_cliente),
    CONSTRAINT fk_id_cuenta_remesa
        FOREIGN KEY (id_cuenta) 
        REFERENCES CUENTA(id_cuenta)
);

CREATE TABLE TIPO_TRANSACCION (
    id_tipo_transaccion INTEGER
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)
        PRIMARY KEY
        NOT NULL,
    nombre VARCHAR2(50) NOT NULL UNIQUE,
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL
);

INSERT INTO TIPO_TRANSACCION (nombre) VALUES ('Débito');
INSERT INTO TIPO_TRANSACCION (nombre) VALUES ('Crédito');
INSERT INTO TIPO_TRANSACCION (nombre) VALUES ('Consumo con tarjeta');
INSERT INTO TIPO_TRANSACCION (nombre) VALUES ('Remesa');
INSERT INTO TIPO_TRANSACCION (nombre) VALUES ('Pago de servicio/producto');
commit;

CREATE TABLE TRANSACCION (
    id_transaccion INTEGER 
        GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1)  
        PRIMARY KEY
        NOT NULL,
    id_tipo_transaccion INTEGER NOT NULL,
    fecha_transaccion TIMESTAMP NOT NULL,
    otros_detalles VARCHAR2(100),
    id_cliente INTEGER NOT NULL,
    id_cuenta INTEGER,
    id_tarjeta INTEGER,
    valor NUMBER(12,2) NOT NULL
        CONSTRAINT chk_monto_positivo_transaccion
        CHECK (valor > 0),
    id_cuenta_origen INTEGER,
    id_cuenta_destino INTEGER,
    CONSTRAINT fk_id_tipo_transaccion_transaccion
        FOREIGN KEY (id_tipo_transaccion) 
        REFERENCES TIPO_TRANSACCION(id_tipo_transaccion),
    CONSTRAINT chk_cuenta_o_tarjeta CHECK (id_cuenta IS NOT NULL OR id_tarjeta IS NOT NULL),
    CONSTRAINT fk_id_cliente_transaccion
        FOREIGN KEY (id_cliente) 
        REFERENCES CLIENTE(id_cliente),
    CONSTRAINT fk_id_cuenta_transaccion
        FOREIGN KEY (id_cuenta) 
        REFERENCES CUENTA(id_cuenta),
    CONSTRAINT fk_id_tarjeta_transaccion
        FOREIGN KEY (id_tarjeta) 
        REFERENCES TARJETA(id_tarjeta),
    CONSTRAINT fk_id_cuenta_origen_transaccion
        FOREIGN KEY (id_cuenta_origen) 
        REFERENCES CUENTA(id_cuenta),
    CONSTRAINT fk_id_cuenta_destino_transaccion
        FOREIGN KEY (id_cuenta_destino) 
        REFERENCES CUENTA(id_cuenta),
    created_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL,
    updated_at TIMESTAMP
        DEFAULT SYSTIMESTAMP
        NOT NULL
);


CREATE OR REPLACE FUNCTION fn_current_money_by_client(
    p_id_cliente IN CLIENTE.id_cliente%TYPE,
    p_id_cuenta IN CUENTA.id_cuenta%TYPE
) RETURN NUMBER IS
    v_saldo NUMBER(12,2);
    v_cuenta_valida NUMBER;
BEGIN
    -- Validar que el cliente existe
    BEGIN
        SELECT COUNT(*) INTO v_cuenta_valida
        FROM CUENTA
        WHERE id_cuenta = p_id_cuenta
        AND id_cliente = p_id_cliente;
        
        IF v_cuenta_valida = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'La cuenta no existe o no pertenece al cliente');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error validando cuenta: ' || SQLERRM);
    END;
    
    -- Obtener el saldo actual
    SELECT saldo_cuenta INTO v_saldo
    FROM CUENTA
    WHERE id_cuenta = p_id_cuenta;
    
    RETURN v_saldo;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20003, 'No se pudo obtener el saldo de la cuenta');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20004, 'Error inesperado: ' || SQLERRM);
END fn_current_money_by_client;
/

CREATE OR REPLACE FUNCTION fn_next_payment(
    p_id_cliente IN CLIENTE.id_cliente%TYPE,
    p_id_prestamo IN PRESTAMO.id_prestamo%TYPE
) RETURN NUMBER IS
    v_cliente_existe NUMBER;
    v_prestamo_existe NUMBER;
    v_proxima_cuota NUMBER;
BEGIN
    -- Validar que el cliente existe
    SELECT COUNT(*) INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;
    
    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20040, 'Error: El cliente especificado no existe');
    END IF;
    
    -- Validar que el préstamo existe y pertenece al cliente
    SELECT COUNT(*) INTO v_prestamo_existe
    FROM PRESTAMO
    WHERE id_prestamo = p_id_prestamo
    AND id_cliente = p_id_cliente;
    
    IF v_prestamo_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20041, 'Error: El préstamo no existe o no pertenece al cliente');
    END IF;
    
    -- Obtener el monto de la próxima cuota pendiente
    SELECT monto_cuota
    INTO v_proxima_cuota
    FROM CUOTA_PRESTAMO
    WHERE id_prestamo = p_id_prestamo
    AND estado = 'PENDIENTE'
    AND fecha_vencimiento = (
        SELECT MIN(fecha_vencimiento)
        FROM CUOTA_PRESTAMO
        WHERE id_prestamo = p_id_prestamo
        AND estado = 'PENDIENTE'
    )
    AND ROWNUM = 1; -- Para asegurar solo un resultado
    
    RETURN v_proxima_cuota;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0; -- No hay cuotas pendientes
    WHEN TOO_MANY_ROWS THEN
        RAISE_APPLICATION_ERROR(-20042, 'Error: Múltiples cuotas encontradas para la misma fecha');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20043, 'Error al consultar próxima cuota: ' || SQLERRM);
END fn_next_payment;
/


CREATE OR REPLACE FUNCTION fn_amount_services_by_client(
    p_id_cliente IN CLIENTE.id_cliente%TYPE,
    p_fecha_inicial IN DATE,
    p_fecha_final IN DATE
) RETURN NUMBER IS
    v_cliente_existe NUMBER;
    v_cantidad_servicios NUMBER := 0;
BEGIN
    -- Validar que el cliente existe
    SELECT COUNT(*) INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;
    
    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20010, 'Error: El cliente especificado no existe');
    END IF;
    
    -- Validar fechas
    IF p_fecha_inicial > p_fecha_final THEN
        RAISE_APPLICATION_ERROR(-20011, 'Error: La fecha inicial no puede ser mayor a la fecha final');
    END IF;
    
    -- Validar que las fechas no sean futuras
    IF p_fecha_inicial > TRUNC(SYSDATE) OR p_fecha_final > TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20012, 'Error: Las fechas no pueden ser futuras');
    END IF;
    
    -- Contar productos/servicios del cliente en el rango de fechas
    SELECT COUNT(*)
    INTO v_cantidad_servicios
    FROM PAGO_PRODUCTO_SERVICIO pps
    JOIN TIPO_PAGO tp ON pps.id_tipo_pago = tp.id_tipo_producto
    WHERE pps.id_cliente = p_id_cliente
    AND TRUNC(pps.created_at) BETWEEN TRUNC(p_fecha_inicial) AND TRUNC(p_fecha_final);
    
    RETURN v_cantidad_servicios;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20013, 'Error al contar servicios: ' || SQLERRM);
END fn_amount_services_by_client;
/



CREATE OR REPLACE FUNCTION fn_avg_services(
    p_fecha_inicial IN DATE,
    p_fecha_final IN DATE
) RETURN NUMBER IS
    v_promedio NUMBER := 0;
    v_clientes_con_servicios NUMBER := 0;
    v_total_servicios NUMBER := 0;
BEGIN
    -- Validar fechas
    IF p_fecha_inicial > p_fecha_final THEN
        RAISE_APPLICATION_ERROR(-20020, 'Error: La fecha inicial no puede ser mayor a la fecha final');
    END IF;
    
    IF p_fecha_inicial > TRUNC(SYSDATE) OR p_fecha_final > TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20021, 'Error: Las fechas no pueden ser futuras');
    END IF;
    
    -- Calcular el promedio de servicios por cliente
    SELECT 
        AVG(servicios_por_cliente)
    INTO 
        v_promedio
    FROM (
        SELECT 
            id_cliente, 
            COUNT(*) as servicios_por_cliente
        FROM 
            PAGO_PRODUCTO_SERVICIO
        WHERE 
            TRUNC(created_at) BETWEEN TRUNC(p_fecha_inicial) AND TRUNC(p_fecha_final)
        GROUP BY 
            id_cliente
    );
    
    -- Si no hay datos, devolver 0 en lugar de NULL
    RETURN NVL(v_promedio, 0);
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20022, 'Error calculando promedio de servicios: ' || SQLERRM);
END fn_avg_services;
/

CREATE OR REPLACE FUNCTION fn_total_amount_services_by_client(
    p_id_cliente IN CLIENTE.id_cliente%TYPE,
    p_fecha_inicial IN DATE,
    p_fecha_final IN DATE
) RETURN NUMBER IS
    v_cliente_existe NUMBER;
    v_total_servicios NUMBER := 0;
BEGIN
    -- Validar que el cliente existe
    SELECT COUNT(*) INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;
    
    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20030, 'Error: El cliente especificado no existe');
    END IF;
    
    -- Validar fechas
    IF p_fecha_inicial > p_fecha_final THEN
        RAISE_APPLICATION_ERROR(-20031, 'Error: La fecha inicial no puede ser mayor a la fecha final');
    END IF;
    
    IF p_fecha_inicial > TRUNC(SYSDATE) OR p_fecha_final > TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20032, 'Error: Las fechas no pueden ser futuras');
    END IF;
    
    -- Calcular el total de servicios del cliente en el rango de fechas
    SELECT NVL(SUM(monto), 0)
    INTO v_total_servicios
    FROM PAGO_PRODUCTO_SERVICIO
    WHERE id_cliente = p_id_cliente
    AND TRUNC(created_at) BETWEEN TRUNC(p_fecha_inicial) AND TRUNC(p_fecha_final);
    
    RETURN v_total_servicios;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20033, 'Error calculando total de servicios: ' || SQLERRM);
END fn_total_amount_services_by_client;
/


CREATE OR REPLACE FUNCTION fn_max_amount_products(
    p_fecha IN DATE
) RETURN NUMBER IS
    v_max_cantidad NUMBER := 0;
BEGIN
    -- Validar que la fecha no sea futura
    IF p_fecha > TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20060, 'Error: La fecha no puede ser futura');
    END IF;
    
    -- Obtener la máxima cantidad de productos/servicios en la fecha
    SELECT MAX(contador)
    INTO v_max_cantidad
    FROM (
        SELECT COUNT(*) AS contador
        FROM PAGO_PRODUCTO_SERVICIO
        WHERE TRUNC(created_at) = TRUNC(p_fecha)
        GROUP BY id_cliente
    );
    
    -- Si no hay registros, devolver 0
    RETURN NVL(v_max_cantidad, 0);
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20061, 'Error calculando máxima cantidad de productos: ' || SQLERRM);
END fn_max_amount_products;
/

CREATE OR REPLACE FUNCTION fn_max_value_products(
    p_fecha IN DATE
) RETURN NUMBER IS
    v_max_monto NUMBER := 0;
BEGIN
    -- Validar que la fecha no sea futura
    IF p_fecha > TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20070, 'Error: La fecha no puede ser futura');
    END IF;
    
    -- Obtener el máximo monto total de pagos por cliente en la fecha
    SELECT MAX(total_monto)
    INTO v_max_monto
    FROM (
        SELECT SUM(monto) AS total_monto
        FROM PAGO_PRODUCTO_SERVICIO
        WHERE TRUNC(created_at) = TRUNC(p_fecha)
        GROUP BY id_cliente
    );
    
    -- Si no hay registros, devolver 0
    RETURN NVL(v_max_monto, 0);
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20071, 'Error calculando máximo monto de productos: ' || SQLERRM);
END fn_max_value_products;
/

/*
Un usuario con privilegios debe de dar los permisos para usar el hash
-- Conéctate como SYS o SYSTEM (usuario con privilegios DBA)
CONNECT sys/password AS SYSDBA

-- Luego ejecutar:
GRANT EXECUTE ON SYS.DBMS_CRYPTO TO pruebas;
GRANT EXECUTE ON SYS.UTL_I18N TO pruebas;
*/

CREATE OR REPLACE PROCEDURE sp_register_new_client(
    p_nombre IN VARCHAR2,
    p_apellido IN VARCHAR2,
    p_numero_telefono IN VARCHAR2,
    p_email IN VARCHAR2,
    p_usuario IN VARCHAR2,
    p_contrasena IN VARCHAR2,
    p_fecha_nacimiento IN DATE,
    p_tipo_cliente IN INTEGER
)
IS
    v_regex_email VARCHAR2(100) := '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$';
    v_regex_letras VARCHAR2(100) := '^[A-Za-záéíóúÁÉÍÓÚÑñÜü\s]+$';
    v_count NUMBER;
    v_tipo_cliente_existe NUMBER;
    v_telefono_limpio VARCHAR2(20);
    v_contrasena_encriptada VARCHAR2(200);
BEGIN
    -- Validar nombre (solo letras)
    IF NOT REGEXP_LIKE(p_nombre, v_regex_letras) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error: El nombre solo puede contener letras y espacios');
    END IF;

    -- Validar apellido (solo letras)
    IF NOT REGEXP_LIKE(p_apellido, v_regex_letras) THEN
        RAISE_APPLICATION_ERROR(-20002, 'Error: El apellido solo puede contener letras y espacios');
    END IF;

    -- Obviar codigo de pais en numero telefonico
    v_telefono_limpio := REGEXP_REPLACE(
        p_numero_telefono,
        '^\+\d{1,5}(?=\s|$)', ''
    );
    
    v_telefono_limpio := TRIM(v_telefono_limpio);

    IF NOT REGEXP_LIKE(v_telefono_limpio, '^[0-9\-]{7,12}$') THEN
        RAISE_APPLICATION_ERROR(-20003, 'Formato telefonico invalido');
    END IF;

    -- Validar email
    IF NOT REGEXP_LIKE(p_email, v_regex_email, 'i') THEN
        RAISE_APPLICATION_ERROR(-20004, 'Error: Formato de email invalido');
    END IF;

    -- Validar disponibilidad de usuario
    SELECT COUNT(*) INTO v_count FROM CLIENTE WHERE usuario = p_usuario;
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20005, 'Error: El nombre de usuario ya esta en uso');
    END IF;

    -- Validar fecha de nacimiento
    IF p_fecha_nacimiento >= TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20006, 'Error: La fecha de nacimiento no es valida');
    END IF;

    -- Validar que el tipo de cliente exista
    SELECT COUNT(*) INTO v_tipo_cliente_existe FROM TIPO_CLIENTE WHERE id_tipo_cliente = p_tipo_cliente;
    IF v_tipo_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20007, 'Error: El tipo de cliente especificado no existe');
    END IF;

    -- Encriptar contraseña (DBMS_CRYPTO)
    v_contrasena_encriptada := DBMS_CRYPTO.HASH(
        UTL_I18N.STRING_TO_RAW(p_contrasena, 'AL32UTF8'),
        DBMS_CRYPTO.HASH_SH256
    );

    -- Insertar el nuevo cliente
    INSERT INTO CLIENTE (
        nombre,
        apellido,
        numero_telefono,
        email,
        usuario,
        contrasena,
        fecha_nacimiento,
        tipo_cliente
    ) VALUES (
        p_nombre,
        p_apellido,
        v_telefono_limpio,
        p_email,
        p_usuario,
        v_contrasena_encriptada,
        p_fecha_nacimiento,
        p_tipo_cliente
    );

    -- Finalizar y mostrar mensaje OK
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Cliente agregado exitosamente');
    
    -- Capturar excepciones
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error al agregar cliente: ' || SQLERRM);
        RAISE;
END sp_register_new_client;
/

CREATE OR REPLACE PROCEDURE sp_register_new_type_client(
    p_nombre IN VARCHAR2,
    p_descripcion IN VARCHAR2
)
IS
    v_regex_letras VARCHAR2(100) := '^[A-Za-zÁÉÍÓÚáéíóúÑñÜü ]+$';
    v_count NUMBER;
BEGIN
    -- Validar descripción (letras y caracteres especiales comunes)
    IF NOT REGEXP_LIKE(p_descripcion, v_regex_letras) THEN
        RAISE_APPLICATION_ERROR(-20011, 'Error: La descripcion contiene caracteres no permitidos');
    END IF;

    -- Validar que el nombre no exista ya
    SELECT COUNT(*) INTO v_count FROM TIPO_CLIENTE WHERE UPPER(nombre) = UPPER(p_nombre);
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20012, 'Error: Ya existe un tipo de cliente con ese nombre');
    END IF;

    -- Insertar el nuevo tipo de cliente
    INSERT INTO TIPO_CLIENTE (
        nombre,
        descripcion
    ) VALUES (
        p_nombre,
        p_descripcion
    );

    -- Finalizar y mostrar mensaje OK
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Tipo de cliente agregado exitosamente');

    -- Capturar excepciones
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error al agregar tipo de cliente: ' || SQLERRM);
        RAISE;
END sp_register_new_type_client;
/


BEGIN
    sp_register_new_type_client(
        p_nombre => 'Individual Nacional',
        p_descripcion => 'Este tipo de cliente es una persona individual de nacionalidad guatemalteca'
    );
END;
/

BEGIN
    sp_register_new_type_client(
        p_nombre => 'Individual Extranjero',
        p_descripcion => 'Este tipo de cliente es una persona individual de nacionalidad extranjera'
    );
END;
/

BEGIN
    sp_register_new_type_client(
        p_nombre => 'Empresa Pyme',
        p_descripcion => 'Este tipo de cliente es una empresa de tipo pequeña o mediana'
    );
END;
/

BEGIN
    sp_register_new_type_client(
        p_nombre => 'Empresa S.C',
        p_descripcion => 'Este tipo de cliente corresponde a las empresa grandes que tienen una sociedad colectiva'
    );
END;
/

BEGIN
    sp_register_new_type_client(
        p_nombre => 'Cuenta del banco',
        p_descripcion => 'Este tipo de cliente corresponde a una cuenta del banco'
    );
END;
/



/*
Forma alternativa
EXEC sp_register_new_type_client('Cuenta de prueba', 'Este tipo de cliente corresponde a una cuenta de prueba');
*/

CREATE OR REPLACE PROCEDURE sp_register_new_account(
    p_id_cliente IN INTEGER,
    p_monto_apertura IN NUMBER,
    p_fecha_apertura IN DATE DEFAULT SYSDATE,
    p_saldo_cuenta IN NUMBER,
    p_tipo_cuenta IN INTEGER,
    p_descripcion IN VARCHAR2 DEFAULT 'Cuenta de banco',
    p_otros_detalles IN VARCHAR2 DEFAULT NULL
)
IS
    v_cliente_existe NUMBER;
    v_tipo_cuenta_existe NUMBER;
    v_cuenta_existe NUMBER;
BEGIN


    -- Validar que el cliente exista
    SELECT COUNT(*) INTO v_cliente_existe FROM CLIENTE WHERE id_cliente = p_id_cliente;
    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20021, 'Error: El ID de cliente no existe');
    END IF;

    -- Validar monto_apertura positivo
    IF p_monto_apertura <= 0 THEN
        RAISE_APPLICATION_ERROR(-20022, 'Error: El monto de apertura debe ser positivo');
    END IF;

    -- Validar saldo_cuenta no negativo
    IF p_saldo_cuenta < 0 THEN
        RAISE_APPLICATION_ERROR(-20023, 'Error: El saldo no puede ser negativo');
    END IF;
    
    -- Validar que el tipo de cuenta exista
    SELECT COUNT(*) INTO v_tipo_cuenta_existe FROM TIPO_CUENTA WHERE id_tipo_cuenta = p_tipo_cuenta;
    IF v_tipo_cuenta_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20025, 'Error: El tipo de cuenta especificado no existe');
    END IF;

    --Verificar fecha valida
    IF p_fecha_apertura IS NOT NULL THEN
        IF p_fecha_apertura > TRUNC(SYSDATE) THEN
            RAISE_APPLICATION_ERROR(-20024, 'Error: La fecha de apertura no puede ser futura');
        END IF;
    END IF;

    

   
    INSERT INTO CUENTA (
    id_cliente,
    monto_apertura,
    saldo_cuenta,
    fecha_apertura,
    tipo_cuenta, 
    descripcion,  
    otros_detalles
    ) VALUES (
        p_id_cliente,
        p_monto_apertura,
        p_saldo_cuenta,
        p_fecha_apertura,
        p_tipo_cuenta,  -- Corregido: estaba usando 'interes' sin prefijo
        p_descripcion,
        p_otros_detalles
    );

    -- Finalizar y mostrar mensaje OK
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Cuenta creada exitosamente');

    -- Capturar excepciones
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error al crear cuenta: ' || SQLERRM);
        RAISE;
END sp_register_new_account;
/

CREATE OR REPLACE PROCEDURE sp_register_new_type_account(
    p_nombre IN VARCHAR2,
    p_descripcion IN VARCHAR2,
    p_interes IN NUMBER DEFAULT 0.0
)
IS
    v_regex_letras VARCHAR2(100) := '^^[A-Za-zÁÉÍÓÚáéíóúÑñÜü ]+$';
    v_count NUMBER;
BEGIN
    -- Validar descripción (letras y caracteres especiales comunes)
    IF NOT REGEXP_LIKE(p_descripcion, v_regex_letras) THEN
        RAISE_APPLICATION_ERROR(-20011, 'Error: La descripcion contiene caracteres no permitidos');
    END IF;

    -- Validar que el nombre no exista ya
    SELECT COUNT(*) INTO v_count FROM TIPO_CUENTA WHERE UPPER(nombre) = UPPER(p_nombre);
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20012, 'Error: Ya existe un tipo de cuenta con ese nombre');
    END IF;

    -- Validar que el interés sea positivo
    IF p_interes < 0 THEN
        RAISE_APPLICATION_ERROR(-20013, 'Error: El interés debe ser positivo');
    END IF;

    -- Insertar el nuevo tipo de cuenta
    INSERT INTO TIPO_CUENTA (
        nombre,
        descripcion,
        interes
    ) VALUES (
        p_nombre,
        p_descripcion,
        p_interes
    );

    -- Finalizar y mostrar mensaje OK
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Tipo de cuenta agregado exitosamente');

    -- Capturar excepciones
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error al agregar tipo de cuenta: ' || SQLERRM);
        RAISE;
END sp_register_new_type_account;
/

BEGIN
    sp_register_new_type_account(
        p_nombre => 'Cuenta Ahorro',
        p_descripcion => 'Esta cuenta genera un interes anual de dos porciento',
        p_interes => 2
    );
END;
/

BEGIN
    sp_register_new_type_account(
        p_nombre => 'Cuenta Ahorro Plus',
        p_descripcion => 'Esta cuenta genera un interés anual del tres punto cinco porciento',
        p_interes => 3.5
    );
END;
/


BEGIN
    sp_register_new_type_account(
        p_nombre => 'Cuenta Monetaria',
        p_descripcion => 'Diseñada para recibir depósitos de sueldo y realizar pagos',
        p_interes => 0
    );
END;
/

BEGIN
    sp_register_new_type_account(
        p_nombre => 'Cuenta Ahorro Empresarial',
        p_descripcion => 'Esta cuenta genera un interés anual de tres porciento',
        p_interes => 3
    );
END;
/

BEGIN
    sp_register_new_type_account(
        p_nombre => 'Cuenta Ahorro Empresarial Plus',
        p_descripcion => 'Esta cuenta genera un interés anual de cinco porciento',
        p_interes => 5
    );
END;
/




CREATE OR REPLACE PROCEDURE sp_calcular_intereses_cuentas IS
    CURSOR c_cuentas IS
        SELECT c.id_cuenta, c.saldo_cuenta, c.fecha_ultimo_interes, 
               c.fecha_apertura, tc.interes, tc.nombre AS tipo_cuenta
        FROM CUENTA c
        JOIN TIPO_CUENTA tc ON c.tipo_cuenta = tc.id_tipo_cuenta
        WHERE c.saldo_cuenta > 0;
    
    v_fecha_actual DATE := TRUNC(SYSDATE);
    v_dias_periodo INTEGER;
    v_intereses NUMBER;
    v_periodo_inicio DATE;
    v_periodo_fin DATE;
BEGIN
    FOR r_cuenta IN c_cuentas LOOP
        -- Determinar fecha de inicio del período de cálculo
        v_periodo_inicio := NVL(r_cuenta.fecha_ultimo_interes, r_cuenta.fecha_apertura);
        v_periodo_fin := v_fecha_actual;
        
        -- Calcular días transcurridos
        v_dias_periodo := v_periodo_fin - v_periodo_inicio;
        
        -- Solo calcular si han pasado días desde el último cálculo
        IF v_dias_periodo > 0 THEN
            -- Calcular intereses (tasa anual → diaria)
            v_intereses := r_cuenta.saldo_cuenta * (r_cuenta.interes/365/100) * v_dias_periodo;
            
            -- Actualizar saldo y fecha de último interés
            UPDATE CUENTA
            SET saldo_cuenta = saldo_cuenta + v_intereses,
                fecha_ultimo_interes = v_fecha_actual
            WHERE id_cuenta = r_cuenta.id_cuenta;
            
            -- Registrar el interés generado (opcional)
            INSERT INTO INTERES_CUENTA (
                id_cuenta,
                fecha_calculo,
                monto_interes,
                periodo_inicio,
                periodo_fin
            ) VALUES (
                r_cuenta.id_cuenta,
                v_fecha_actual,
                v_intereses,
                v_periodo_inicio,
                v_periodo_fin
            );
            
            DBMS_OUTPUT.PUT_LINE('Cuenta ' || r_cuenta.id_cuenta || ' (' || r_cuenta.tipo_cuenta || 
                                '): Intereses calculados: ' || v_intereses);
        END IF;
    END LOOP;
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Proceso de cálculo de intereses completado');
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error al calcular intereses: ' || SQLERRM);
        RAISE;
END sp_calcular_intereses_cuentas;
/

CREATE OR REPLACE PROCEDURE sp_register_notification(
    p_id_cliente IN CLIENTE.id_cliente%TYPE,
    p_mensaje IN NOTIFICACION.mensaje%TYPE,
    p_fecha IN NOTIFICACION.fecha%TYPE
) AS
    v_id_notificacion NOTIFICACION.id_notificacion%TYPE;
    v_cliente_existe INTEGER;
BEGIN
    -- Verificar si el cliente existe
    SELECT COUNT(*)
    INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;

    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'El cliente no existe.');
    END IF;
    
    IF p_mensaje is null then
        RAISE_APPLICATION_ERROR(-20001, 'Incluya un mensaje para la notificacion');
    END IF;

    -- Insertar la notificación
    INSERT INTO NOTIFICACION (id_cliente, mensaje, fecha)
    VALUES (p_id_cliente, p_mensaje, p_fecha)
    RETURNING id_notificacion INTO v_id_notificacion;

    DBMS_OUTPUT.PUT_LINE('Notificación registrada con ID: ' || v_id_notificacion);
    COMMIT; -- Confirmar la transacción

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK; -- Deshacer la transacción en caso de error
            DBMS_OUTPUT.PUT_LINE('Error al registrar la notificación: ' || SQLERRM);
END sp_register_notification;
/

CREATE OR REPLACE PROCEDURE sp_register_award(
    p_id_cliente IN CLIENTE.id_cliente%TYPE,
    p_id_tarjeta IN TARJETA.id_tarjeta%TYPE,
    p_premio IN PREMIO.premio%TYPE,
    p_fecha IN PREMIO.fecha%TYPE
) AS
    v_id_premio PREMIO.id_premio%TYPE;
    v_cliente_existe INTEGER;
    v_tarjeta_existe INTEGER;
BEGIN
    -- Verificar si el cliente existe
    SELECT COUNT(*)
    INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;

    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'El cliente no existe.');
    END IF;

    -- Verificar si la tarjeta existe
    SELECT COUNT(*)
    INTO v_tarjeta_existe
    FROM TARJETA
    WHERE id_tarjeta = p_id_tarjeta;

    IF v_tarjeta_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'La tarjeta no existe.');
    END IF;

    -- Insertar el premio
    INSERT INTO PREMIO (id_cliente, id_tarjeta, premio, fecha)
    VALUES (p_id_cliente, p_id_tarjeta, p_premio, p_fecha)
    RETURNING id_premio INTO v_id_premio;

    DBMS_OUTPUT.PUT_LINE('Premio registrado con ID: ' || v_id_premio);
    COMMIT; -- Confirmar la transacción


    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK; -- Deshacer la transacción en caso de error

            DBMS_OUTPUT.PUT_LINE('Error al registrar el premio: ' || SQLERRM);
END sp_register_award;
/

CREATE OR REPLACE VIEW v_notificaciones_cliente AS
SELECT 
    n.id_notificacion,
    n.mensaje,
    n.fecha,
    n.id_cliente,
    c.nombre || ' ' || c.apellido AS nombre_cliente
FROM 
    NOTIFICACION n
JOIN 
    CLIENTE c ON n.id_cliente = c.id_cliente;
    
    
CREATE OR REPLACE PROCEDURE sp_notifications_by_client(
    p_id_cliente IN CLIENTE.id_cliente%TYPE
) AS
    v_cliente_existe INTEGER;
    v_notificaciones_count INTEGER := 0;
BEGIN
    -- Verificar si el cliente existe
    SELECT COUNT(*)
    INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;

    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error: El cliente con ID ' || p_id_cliente || ' no existe.');
    END IF;

    -- Mostrar las notificaciones del cliente
    DBMS_OUTPUT.PUT_LINE('Notificaciones para el cliente ID: ' || p_id_cliente);
    DBMS_OUTPUT.PUT_LINE('----------------------------------------');
    
    FOR r IN (
        SELECT id_notificacion, mensaje, TO_CHAR(fecha, 'DD/MM/YYYY HH24:MI:SS') AS fecha_formateada 
        FROM v_notificaciones_cliente 
        WHERE id_cliente = p_id_cliente
        ORDER BY fecha DESC
    ) LOOP
        DBMS_OUTPUT.PUT_LINE(
            'ID: ' || RPAD(r.id_notificacion, 10) || 
            ' | Fecha: ' || RPAD(r.fecha_formateada, 20) || 
            ' | Mensaje: ' || r.mensaje
        );
        v_notificaciones_count := v_notificaciones_count + 1;
    END LOOP;
    
    -- Mostrar mensaje si no hay notificaciones
    IF v_notificaciones_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('El cliente no tiene notificaciones.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('----------------------------------------');
        DBMS_OUTPUT.PUT_LINE('Total notificaciones: ' || v_notificaciones_count);
    END IF;
END sp_notifications_by_client;
/

CREATE OR REPLACE VIEW v_premios_cliente AS
SELECT 
    p.id_cliente,
    p.id_premio,
    p.premio,
    t.numero_tarjeta,
    tt.nombre AS tipo_tarjeta,
    c.nombre || ' ' || c.apellido AS nombre_cliente
FROM
    PREMIO p
JOIN 
    TARJETA t ON p.id_tarjeta = t.id_tarjeta
JOIN
    CLIENTE c ON p.id_cliente = c.id_cliente
JOIN
    TIPO_TARJETA tt ON t.id_tipo_tarjeta = tt.id_tipo_tarjeta;


CREATE OR REPLACE PROCEDURE sp_awards_by_client(
    p_id_cliente IN CLIENTE.id_cliente%TYPE
) AS
    v_cliente_existe INTEGER;
    v_premios_count INTEGER := 0;
BEGIN
    -- Verificar si el cliente existe
    SELECT COUNT(*)
    INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;

    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error: El cliente con ID ' || p_id_cliente || ' no existe.');
    END IF;

    -- Mostrar los premios del cliente
    DBMS_OUTPUT.PUT_LINE('Premios para el cliente ID: ' || p_id_cliente);
    DBMS_OUTPUT.PUT_LINE('----------------------------------------');
    
    FOR r IN (
        SELECT id_premio, premio, numero_tarjeta, tipo_tarjeta, nombre_cliente 
        FROM v_premios_cliente 
        WHERE id_cliente = p_id_cliente
    ) LOOP
        DBMS_OUTPUT.PUT_LINE(
            'ID: ' || RPAD(r.id_premio, 10) || 
            ' | Premio: ' || RPAD(r.premio, 10) || 
            ' | Tarjeta: ' || RPAD(r.numero_tarjeta, 20) ||
            ' | Tipo Tarjeta: ' || RPAD(r.tipo_tarjeta, 20) ||
            ' | Cliente: ' || r.nombre_cliente
        );
        v_premios_count := v_premios_count + 1;
    END LOOP;
    
    -- Mostrar mensaje si no hay premios
    IF v_premios_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('El cliente no tiene premios.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('----------------------------------------');
        DBMS_OUTPUT.PUT_LINE('Total premios: ' || v_premios_count);
    END IF;
END sp_awards_by_client;
/

--Procedimientos relacionados con prestamos
CREATE OR REPLACE PROCEDURE sp_get_loan(
    p_id_cliente IN INTEGER,
    p_monto_prestamo IN NUMBER,
    p_tasa_interes IN NUMBER,
    p_meses IN INTEGER
) IS
    v_id_prestamo INTEGER;
    v_fecha_vencimiento DATE;
    v_monto_cuota NUMBER(12,2);
    v_interes_mensual NUMBER;
    v_tasa_mensual NUMBER;
    v_saldo_restante NUMBER;
    v_capital_cuota NUMBER;
    v_interes_cuota NUMBER;
    v_cliente_existe INTEGER;
BEGIN
    
    --Validar que el cliente existe
    SELECT COUNT(*)
    INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;


    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'El cliente no existe');
    END IF;

    -- Validaciones básicas
    IF p_monto_prestamo <= 0 THEN
        RAISE_APPLICATION_ERROR(-20020, 'El monto del préstamo debe ser positivo');
    END IF;
    
    IF p_tasa_interes < 0 THEN
        RAISE_APPLICATION_ERROR(-20021, 'La tasa de interés no puede ser negativa');
    END IF;
    
    IF p_meses <= 0 THEN
        RAISE_APPLICATION_ERROR(-20022, 'El plazo en meses debe ser positivo');
    END IF;
    
    -- Calcular fecha de vencimiento
    v_fecha_vencimiento := ADD_MONTHS(TRUNC(SYSDATE), p_meses);
    
    -- Insertar el préstamo principal
    INSERT INTO PRESTAMO (
        id_cliente,
        monto_prestamo,
        tasa_interes,
        meses,
        monto_restante,
        meses_restantes,
        fecha_vencimiento
    ) VALUES (
        p_id_cliente,
        p_monto_prestamo,
        p_tasa_interes,
        p_meses,
        p_monto_prestamo, -- Inicialmente igual al monto total
        p_meses,          -- Todos los meses pendientes al inicio
        v_fecha_vencimiento
    ) RETURNING id_prestamo INTO v_id_prestamo;
    
    -- Calcular tasa mensual (convertimos tasa anual a mensual)
    v_tasa_mensual := p_tasa_interes / 12 / 100;
    
    -- Calcular cuota mensual
    v_monto_cuota := p_monto_prestamo * (v_tasa_mensual * POWER(1 + v_tasa_mensual, p_meses)) / 
                    (POWER(1 + v_tasa_mensual, p_meses) - 1);
    
    v_saldo_restante := p_monto_prestamo;
    
    -- Generar todas las cuotas
    FOR i IN 1..p_meses LOOP
        v_interes_cuota := v_saldo_restante * v_tasa_mensual;
        v_capital_cuota := v_monto_cuota - v_interes_cuota;
        v_saldo_restante := v_saldo_restante - v_capital_cuota;
        
        -- Insertar la cuota
        INSERT INTO CUOTA_PRESTAMO (
            id_prestamo,
            numero_cuota,
            fecha_vencimiento,
            monto_cuota,
            capital,
            interes,
            saldo_restante
        ) VALUES (
            v_id_prestamo,
            i,
            ADD_MONTHS(TRUNC(SYSDATE), i),
            v_monto_cuota,
            v_capital_cuota,
            v_interes_cuota,
            v_saldo_restante
        );
    END LOOP;
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Préstamo creado exitosamente. ID: ' || v_id_prestamo);
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error al crear préstamo: ' || SQLERRM);
        RAISE;
END sp_get_loan;
/

CREATE OR REPLACE FUNCTION fn_pagar_proxima_cuota(
    p_id_prestamo IN INTEGER,
    p_fecha_pago IN DATE DEFAULT SYSDATE,
    p_monto_pagado IN NUMBER DEFAULT NULL
) RETURN VARCHAR2 IS
    v_cuota CUOTA_PRESTAMO%ROWTYPE;
    v_prestamo PRESTAMO%ROWTYPE;
    v_resultado VARCHAR2(200);
    
    -- Definimos excepciones personalizadas
    e_prestamo_no_encontrado EXCEPTION;
    e_no_cuotas_pendientes EXCEPTION;
    e_monto_insuficiente EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_prestamo_no_encontrado, -20001);
    PRAGMA EXCEPTION_INIT(e_no_cuotas_pendientes, -20002);
    PRAGMA EXCEPTION_INIT(e_monto_insuficiente, -20003);
BEGIN
    -- Validar que el préstamo existe
    BEGIN
        SELECT * INTO v_prestamo
        FROM PRESTAMO
        WHERE id_prestamo = p_id_prestamo;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE e_prestamo_no_encontrado;
    END;
    
    -- Buscar la próxima cuota pendiente
    BEGIN
        SELECT * INTO v_cuota
        FROM (
            SELECT *
            FROM CUOTA_PRESTAMO
            WHERE id_prestamo = p_id_prestamo
            AND estado = 'PENDIENTE'
            ORDER BY numero_cuota ASC
        )
        WHERE ROWNUM = 1;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE e_no_cuotas_pendientes;
    END;
    
    -- Validar monto si se especificó
    IF p_monto_pagado IS NOT NULL AND p_monto_pagado < v_cuota.monto_cuota THEN
        RAISE e_monto_insuficiente;
    END IF;
    
    -- Realizar el pago
    UPDATE CUOTA_PRESTAMO
    SET estado = 'PAGADA',
        fecha_pago = p_fecha_pago
    WHERE id_prestamo = p_id_prestamo
    AND numero_cuota = v_cuota.numero_cuota;
    
    UPDATE PRESTAMO
    SET monto_restante = monto_restante - v_cuota.capital,
        meses_restantes = meses_restantes - 1
    WHERE id_prestamo = p_id_prestamo;
    
    COMMIT;
    
    -- Construir mensaje de éxito
    v_resultado := 'EXITO: Cuota #' || v_cuota.numero_cuota || ' pagada. ' ||
                  'Capital: ' || TO_CHAR(v_cuota.capital, 'L999G990D00') || 
                  ' | Interés: ' || TO_CHAR(v_cuota.interes, 'L999G990D00');
    
    -- Verificar si es la última cuota
    IF v_prestamo.meses_restantes - 1 = 0 THEN
        v_resultado := v_resultado || ' | ¡Préstamo completado!';
    END IF;
    
    RETURN v_resultado;
EXCEPTION
    WHEN e_prestamo_no_encontrado THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20001, 'Préstamo no encontrado');
    WHEN e_no_cuotas_pendientes THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20002, 'No hay cuotas pendientes para este préstamo');
    WHEN e_monto_insuficiente THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20003, 'Monto insuficiente para pagar la cuota completa');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20099, 'Error al procesar pago: ' || SUBSTR(SQLERRM, 1, 200));
END fn_pagar_proxima_cuota;
/

CREATE OR REPLACE PROCEDURE sp_verificar_moras IS
BEGIN
    -- Marcar cuotas vencidas no pagadas
    UPDATE CUOTA_PRESTAMO
    SET estado = 'VENCIDA'
    WHERE estado = 'PENDIENTE'
    AND fecha_vencimiento < TRUNC(SYSDATE);

    -- Marcar cuotas con mora mayor a 30 días
    UPDATE CUOTA_PRESTAMO
    SET estado = 'MORA'
    WHERE estado = 'VENCIDA'
    AND fecha_vencimiento < ADD_MONTHS(TRUNC(SYSDATE), -1);

    --Agregar notificacion al cliente con el procedimiento de notificaciones
    FOR r IN (
    SELECT DISTINCT p.id_cliente, c.estado, c.id_prestamo
    FROM PRESTAMO p
    JOIN CUOTA_PRESTAMO c ON p.id_prestamo = c.id_prestamo
    WHERE c.estado IN ('VENCIDA', 'MORA')
    ) LOOP
        IF r.estado = 'MORA' THEN
            sp_register_notification(
                r.id_cliente,
                'La cuota del préstamo ' || r.id_prestamo || ' está en mora',
                SYSDATE
            );
        ELSIF r.estado = 'VENCIDA' THEN
            sp_register_notification(
                r.id_cliente,
                'La cuota del préstamo ' || r.id_prestamo || ' está vencida',
                SYSDATE
            );
        END IF;
    END LOOP;

    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Verificación de moras completada: ' || SQL%ROWCOUNT || ' cuotas actualizadas');
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error al verificar moras: ' || SQLERRM);
END sp_verificar_moras;
/

CREATE OR REPLACE PROCEDURE sp_consultar_cuotas_pendientes(
    p_id_prestamo IN INTEGER
) IS
    CURSOR c_cuotas IS
        SELECT numero_cuota, fecha_vencimiento, monto_cuota
        FROM CUOTA_PRESTAMO
        WHERE id_prestamo = p_id_prestamo
        AND estado = 'PENDIENTE'
        ORDER BY numero_cuota;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Cuotas pendientes para el préstamo ' || p_id_prestamo);
    DBMS_OUTPUT.PUT_LINE('--------------------------------------');
    
    FOR cuota IN c_cuotas LOOP
        DBMS_OUTPUT.PUT_LINE('Cuota #' || cuota.numero_cuota || 
                            ' - Vence: ' || TO_CHAR(cuota.fecha_vencimiento, 'DD/MM/YYYY') || 
                            ' - Monto: ' || TO_CHAR(cuota.monto_cuota, 'L999G990D00'));
    END LOOP;
END sp_consultar_cuotas_pendientes;
/

CREATE OR REPLACE PROCEDURE p_actualizar_tarjetas_por_cuenta(
    p_id_cuenta IN CUENTA.id_cuenta%TYPE
) IS
    v_saldo_cuenta CUENTA.saldo_cuenta%TYPE;
BEGIN
    -- Obtener saldo actual de la cuenta con bloqueo
    SELECT saldo_cuenta INTO v_saldo_cuenta
    FROM CUENTA
    WHERE id_cuenta = p_id_cuenta
    FOR UPDATE;
    
    -- Validar saldo no negativo
    IF v_saldo_cuenta < 0 THEN
        RAISE_APPLICATION_ERROR(-20010, 'El saldo de la cuenta no puede ser negativo');
    END IF;
    
    -- Actualizar todas las tarjetas de débito asociadas
    UPDATE TARJETA
    SET saldo_tarjeta = v_saldo_cuenta,
        monto_limite = v_saldo_cuenta,
        updated_at = SYSTIMESTAMP
    WHERE id_cuenta = p_id_cuenta
    AND id_tipo = 'D';
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Actualizadas ' || SQL%ROWCOUNT || ' tarjetas de débito');
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20011, 'La cuenta especificada no existe');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20012, 'Error actualizando tarjetas: ' || SQLERRM);
END p_actualizar_tarjetas_por_cuenta;
/

CREATE OR REPLACE PROCEDURE p_actualizar_cuenta_por_tarjeta(
    p_id_tarjeta IN TARJETA.id_tarjeta%TYPE,
    p_monto_consumo IN NUMBER
) IS
    v_id_cuenta TARJETA.id_cuenta%TYPE;
    v_tipo_tarjeta TARJETA.id_tipo%TYPE;
    v_saldo_cuenta CUENTA.saldo_cuenta%TYPE;
BEGIN
    -- Obtener información de la tarjeta
    BEGIN
        SELECT id_cuenta, id_tipo INTO v_id_cuenta, v_tipo_tarjeta
        FROM TARJETA
        WHERE id_tarjeta = p_id_tarjeta;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20022, 'La tarjeta especificada no existe');
    END;
    
    -- Solo procesar si es tarjeta de débito con cuenta asociada
    IF v_tipo_tarjeta = 'D' AND v_id_cuenta IS NOT NULL THEN
        -- Actualizar saldo de la cuenta con bloqueo
        BEGIN
            UPDATE CUENTA
            SET saldo_cuenta = saldo_cuenta - p_monto_consumo,
                updated_at = SYSTIMESTAMP
            WHERE id_cuenta = v_id_cuenta
            RETURNING saldo_cuenta INTO v_saldo_cuenta;
            
            -- Validar que no quede saldo negativo
            IF v_saldo_cuenta < 0 THEN
                ROLLBACK;
                RAISE_APPLICATION_ERROR(-20021, 'Saldo insuficiente en la cuenta');
            END IF;
            
            -- Actualizar la tarjeta con el nuevo saldo
            UPDATE TARJETA
            SET saldo_tarjeta = v_saldo_cuenta,
                monto_limite = v_saldo_cuenta,
                updated_at = SYSTIMESTAMP
            WHERE id_tarjeta = p_id_tarjeta;
            
            COMMIT;
            
            DBMS_OUTPUT.PUT_LINE('Cuenta y tarjeta actualizadas. Nuevo saldo: ' || v_saldo_cuenta);
        EXCEPTION
            WHEN OTHERS THEN
                ROLLBACK;
                RAISE_APPLICATION_ERROR(-20023, 'Error actualizando cuenta: ' || SQLERRM);
        END;
    ELSE
        -- Para tarjetas de crédito o sin cuenta asociada, simplemente salir sin error
        DBMS_OUTPUT.PUT_LINE('Operación no requerida para este tipo de tarjeta');
        RETURN;
    END IF;
END p_actualizar_cuenta_por_tarjeta;
/

CREATE OR REPLACE PROCEDURE sp_calcular_intereses_tarjeta(
    p_id_tarjeta IN INTEGER
) IS
    v_tarjeta TARJETA%ROWTYPE;
    v_dias_transcurridos INTEGER;
    v_intereses NUMBER := 0;
    v_fecha_actual DATE := TRUNC(SYSDATE);
BEGIN
    -- Obtener datos de la tarjeta
    SELECT * INTO v_tarjeta
    FROM TARJETA
    WHERE id_tarjeta = p_id_tarjeta;
    
    -- Solo para tarjetas de crédito
    IF v_tarjeta.id_tipo = 'D' THEN
        RETURN; -- Tarjetas de débito no generan intereses
    END IF;
    
    -- Calcular días desde el último cálculo (o desde creación)
    v_dias_transcurridos := v_fecha_actual - NVL(v_tarjeta.fecha_ultimo_interes, v_tarjeta.created_at);
    
    -- Solo calcular si hay saldo pendiente y han pasado días
    IF (v_tarjeta.monto_limite - v_tarjeta.saldo_tarjeta) > 0 AND v_dias_transcurridos > 0 THEN
        -- Calcular intereses (tasa anual → diaria)
        v_intereses := (v_tarjeta.monto_limite - v_tarjeta.saldo_tarjeta) * (v_tarjeta.tasa_interes/365/100) * v_dias_transcurridos;
        
        -- Actualizar saldo y fecha
        UPDATE TARJETA
        SET saldo_tarjeta = saldo_tarjeta - v_intereses,
            fecha_ultimo_interes = v_fecha_actual
        WHERE id_tarjeta = p_id_tarjeta;
        
        -- Registrar movimiento
        INSERT INTO MOVIMIENTO_TARJETA (
            id_tarjeta,
            fecha_movimiento,
            monto,
            descripcion,
            tipo
        ) VALUES (
            p_id_tarjeta,
            SYSTIMESTAMP,
            v_intereses,
            'Intereses generados',
            'D'
        );
        
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error calculando intereses: ' || SQLERRM);
        RAISE;
END sp_calcular_intereses_tarjeta;
/

CREATE OR REPLACE PROCEDURE sp_pagar_tarjeta(
    p_id_tarjeta IN INTEGER,
    p_monto IN NUMBER
) IS
    v_saldo_actual NUMBER;
    v_tarjeta TARJETA%ROWTYPE;
BEGIN
    -- Calcular intereses acumulados hasta hoy
    sp_calcular_intereses_tarjeta(p_id_tarjeta);
    
    -- Obtener saldo actualizado
    SELECT saldo_tarjeta INTO v_saldo_actual
    FROM TARJETA
    WHERE id_tarjeta = p_id_tarjeta;

    SELECT * INTO v_tarjeta
    FROM TARJETA
    WHERE id_tarjeta = p_id_tarjeta;
    
    -- Validar que el pago no exceda el saldo (para tarjetas de crédito)
    DECLARE
        v_tipo_tarjeta VARCHAR2(1);
    BEGIN
        SELECT id_tipo INTO v_tipo_tarjeta
        FROM TARJETA
        WHERE id_tarjeta = p_id_tarjeta;
        
        IF v_tipo_tarjeta = 'C' AND p_monto > (v_tarjeta.monto_limite - v_tarjeta.saldo_tarjeta) THEN
            RAISE_APPLICATION_ERROR(-20002, 'No puede pagar más que el saldo actual');
        END IF;
    END;
    
    -- Aplicar el pago
    UPDATE TARJETA
    SET saldo_tarjeta = saldo_tarjeta + p_monto
    WHERE id_tarjeta = p_id_tarjeta;
    
    INSERT INTO MOVIMIENTO_TARJETA (
        id_tarjeta,
        fecha_movimiento,
        monto,
        descripcion,
        tipo
    ) VALUES (
        p_id_tarjeta,
        SYSTIMESTAMP,
        p_monto,
        'Pago realizado',
        'C'
    );
    
    -- Si el saldo queda en cero, resetear fecha de últimos intereses
    IF ((v_tarjeta.monto_limite - v_tarjeta.saldo_tarjeta) - p_monto) <= 0 THEN
        UPDATE TARJETA
        SET fecha_ultimo_interes = NULL
        WHERE id_tarjeta = p_id_tarjeta;
    END IF;
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Pago aplicado. Nuevo saldo: ' || (v_saldo_actual - p_monto));
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error en pago: ' || SQLERRM);
        RAISE;
END sp_pagar_tarjeta;
/

CREATE OR REPLACE PROCEDURE sp_register_new_card(
    p_id_cliente IN INTEGER,
    p_id_cuenta IN INTEGER DEFAULT NULL,
    p_id_tipo_tarjeta IN INTEGER,
    p_id_tipo IN VARCHAR2,
    p_numero_tarjeta IN NUMBER,
    p_moneda IN VARCHAR2,
    p_monto_limite IN NUMBER DEFAULT null,
    p_dia_corte IN INTEGER,
    p_dia_pago IN INTEGER,
    p_tasa_interes IN INTEGER DEFAULT 0
)
IS
    v_cliente_existe NUMBER;
    v_cuenta_existe NUMBER;
    v_tipo_tarjeta_existe NUMBER;
    v_tarjeta_existe NUMBER;
    v_fecha_vencimiento DATE;
    v_fecha_actual DATE := SYSDATE;
    p_saldo_tarjeta NUMBER(12,2) := p_monto_limite;
BEGIN
    -- Validar que el número de tarjeta no esté duplicado
    SELECT COUNT(*) INTO v_tarjeta_existe FROM TARJETA WHERE numero_tarjeta = p_numero_tarjeta;
    IF v_tarjeta_existe > 0 THEN
        RAISE_APPLICATION_ERROR(-20030, 'Error: El número de tarjeta ya está registrado');
    END IF;

    --Validar que el número de tarjeta tenga 16 dígitos y sean solo numeros
    IF LENGTH(p_numero_tarjeta) != 16 OR NOT REGEXP_LIKE(p_numero_tarjeta, '^[0-9]+$') THEN
        RAISE_APPLICATION_ERROR(-20032, 'Error: El número de tarjeta debe tener 16 dígitos y ser solo números');
    END IF;

    -- Validar que el cliente exista
    SELECT COUNT(*) INTO v_cliente_existe FROM CLIENTE WHERE id_cliente = p_id_cliente;
    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20031, 'Error: El ID de cliente no existe');
    END IF;

    -- Validar que el tipo de tarjeta exista
    SELECT COUNT(*) INTO v_tipo_tarjeta_existe FROM TIPO_TARJETA WHERE id_tipo_tarjeta = p_id_tipo_tarjeta;
    IF v_tipo_tarjeta_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20033, 'Error: El tipo de tarjeta especificado no existe');
    END IF;

    -- Validar monto_limite positivo
    IF p_monto_limite is not null and p_monto_limite <= 0 THEN
        RAISE_APPLICATION_ERROR(-20034, 'Error: El monto límite debe ser positivo');
    END IF;

    -- Validar saldo_tarjeta no negativo
    IF p_saldo_tarjeta < 0 THEN
        RAISE_APPLICATION_ERROR(-20035, 'Error: El saldo no puede ser negativo');
    END IF; 

    IF p_dia_corte < 1 OR p_dia_corte > 31 THEN
        RAISE_APPLICATION_ERROR(-20036, 'Error: El día de corte debe estar entre 1 y 31');
    END IF;

    IF p_dia_pago < 1 OR p_dia_pago > 31 THEN
        RAISE_APPLICATION_ERROR(-20037, 'Error: El día de pago debe estar entre 1 y 31');
    END IF; 

    IF p_tasa_interes < 0 OR p_tasa_interes > 100 THEN
        RAISE_APPLICATION_ERROR(-20038, 'Error: La tasa de interés debe estar entre 0 y 100');
    END IF;

    IF p_id_tipo NOT IN ('C', 'D') THEN
        RAISE_APPLICATION_ERROR(-20039, 'Error: El tipo de tarjeta debe ser "C" o "D"');
    END IF;

    IF p_moneda NOT IN ('Q', '$') THEN
        RAISE_APPLICATION_ERROR(-20040, 'Error: La moneda debe ser "Q" o "$"');
    END IF;

    -- El campo id_cuenta es opcional, solo si p_id_tipo es 'D', debe tener una cuenta asociada
    IF p_id_tipo = 'D' AND p_id_cuenta IS NULL THEN
        RAISE_APPLICATION_ERROR(-20041, 'Error: Para el tipo de tarjeta "D" se requiere una cuenta asociada');
    END IF;

    -- Si se proporciona una cuenta y la tarjeta es de tipo 'C', daros un error
    IF p_id_tipo = 'C' AND p_id_cuenta IS NOT NULL THEN
        RAISE_APPLICATION_ERROR(-20042, 'Error: Para el tipo de tarjeta "C" no se debe asociar una cuenta');
    END IF;

    -- Si es de tipo 'D', verificar que la cuenta exista
    IF p_id_tipo = 'D' THEN
        SELECT COUNT(*) INTO v_cuenta_existe FROM CUENTA WHERE id_cuenta = p_id_cuenta;
        IF v_cuenta_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20043, 'Error: La cuenta especificada no existe');
        END IF;
    END IF;


    -- Calcular la fecha de vencimiento (5 años a partir de la fecha actual)
    v_fecha_vencimiento := ADD_MONTHS(v_fecha_actual, 60); -- 5 años = 60 meses


    -- Insertar la nueva tarjeta
    INSERT INTO TARJETA (
        id_cliente,
        id_cuenta,
        id_tipo_tarjeta,
        id_tipo,
        numero_tarjeta,
        moneda,
        monto_limite,
        saldo_tarjeta,
        dia_corte,
        dia_pago,
        tasa_interes,
        fecha_vencimiento
    ) VALUES (
        p_id_cliente,
        p_id_cuenta,
        p_id_tipo_tarjeta,
        p_id_tipo,
        p_numero_tarjeta,
        p_moneda,
        p_monto_limite,
        p_monto_limite, -- Inicialmente el saldo es igual al monto límite
        p_dia_corte,
        p_dia_pago,
        p_tasa_interes,
        v_fecha_vencimiento
    );

    COMMIT; -- Confirmar la transacción

    DBMS_OUTPUT.PUT_LINE('Tarjeta registrada exitosamente con número: ' || p_numero_tarjeta);

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK; -- Deshacer la transacción en caso de error
        RAISE_APPLICATION_ERROR(-20044, 'Error al registrar la tarjeta: ' || SQLERRM);
END sp_register_new_card;
/

CREATE OR REPLACE PROCEDURE sp_get_insurance(
    p_id_tipo_seguro IN INTEGER,
    p_monto_asegurado IN NUMBER,
    p_valor_seguro IN NUMBER,
    p_cantidad_pagos IN INTEGER,
    p_meses_asegurados IN INTEGER,
    p_id_cliente IN INTEGER
)
IS
    v_fecha_vencimiento TIMESTAMP;
    v_fecha_contratacion TIMESTAMP;
    v_cliente_existente INTEGER;

BEGIN
    -- Paso 1 verificaciones de valores posuivos y existencias de cliente y tipo de seguro
    IF p_monto_asegurado <= 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'El monto asegurado debe ser mayor a 0.');
    END IF;

    IF p_valor_seguro <= 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'El valor del seguro debe ser mayor a 0.');
    END IF;

    IF p_cantidad_pagos <= 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'La cantidad de pagos debe ser mayor a 0.');
    END IF;

    IF p_meses_asegurados <= 0 THEN
        RAISE_APPLICATION_ERROR(-20004, 'Los meses asegurados deben ser mayor a 0.');
    END IF;

    -- Verificar si el cliente existe
    SELECT COUNT(*)
    INTO v_cliente_existente
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;


    IF v_cliente_existente = 0 THEN
        RAISE_APPLICATION_ERROR(-20005, 'El cliente no existe.');
    END IF;

    --Si se pasaron todas las validaciones, se procede a insertar el seguro
    -- Paso 2 calcular la fecha de vencimiento y la fecha de contratacion
    -- a La fecha actual se le suma la cantidad de meses asegurados
    v_fecha_contratacion := SYSTIMESTAMP;
    v_fecha_vencimiento := ADD_MONTHS(v_fecha_contratacion, p_meses_asegurados);

    -- Paso 3 insertar el seguro
    INSERT INTO SEGURO (id_tipo_seguro, id_cliente, monto_asegurado, valor_seguro, cantidad_pagos, meses_asegurados, fecha_contratacion, fecha_vencimiento)
    VALUES (p_id_tipo_seguro, p_id_cliente, p_monto_asegurado, p_valor_seguro, p_cantidad_pagos, p_meses_asegurados, v_fecha_contratacion, v_fecha_vencimiento);

    COMMIT;

    DBMS_OUTPUT.PUT_LINE('Seguro creado con éxito. ID del seguro: ' || SQL%ROWCOUNT);

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error al crear el seguro: ' || SQLERRM);
END sp_get_insurance;
/

CREATE OR REPLACE PROCEDURE sp_comming_money(
    p_id_empresa_remesa IN EMPRESA_REMESA.id_empresa_remesa%TYPE,
    p_fecha IN REMESA.fecha%TYPE,
    p_pais IN REMESA.pais%TYPE,
    p_id_cliente IN REMESA.id_cliente%TYPE,
    p_id_cuenta IN REMESA.id_cuenta%TYPE,
    p_monto IN REMESA.monto%TYPE
) AS
    v_cliente_existe INTEGER;
    v_cuenta_existe INTEGER;
    v_empresa_existe INTEGER;

BEGIN
    -- Verificar si el cliente existe
    SELECT COUNT(*)
    INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;

    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'El cliente no existe.');
    END IF;

    --Verificar si el monto es positivo
    IF p_monto <= 0 THEN
        RAISE_APPLICATION_ERROR(-20004, 'El monto debe ser positivo.');
    END IF;

    -- Verificar si la cuenta existe
    SELECT COUNT(*)
    INTO v_cuenta_existe
    FROM CUENTA
    WHERE id_cuenta = p_id_cuenta;

    IF v_cuenta_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'La cuenta no existe.');
    END IF;

    -- Verificar si la empresa de remesa existe
    SELECT COUNT(*)
    INTO v_empresa_existe
    FROM EMPRESA_REMESA
    WHERE id_empresa_remesa = p_id_empresa_remesa;

    IF v_empresa_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'La empresa de remesa no existe.');
    END IF;

    -- Insertar la remesa en la tabla REMESA
    INSERT INTO REMESA (id_empresa_remesa, fecha, pais, id_cliente, id_cuenta, monto)
    VALUES (p_id_empresa_remesa, p_fecha, p_pais, p_id_cliente, p_id_cuenta, p_monto);

    COMMIT; -- Confirmar la transacción
    DBMS_OUTPUT.PUT_LINE('Remesa registrada exitosamente.');

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error al insertar remesa: ' || SQLERRM);
        RAISE;

END sp_comming_money;
/


CREATE OR REPLACE VIEW v_remesas_cliente AS
SELECT
    r.id_remesa,
    r.id_cliente,
    e.nombre AS empresa_remesa,
    r.monto,
    r.fecha,
    r.pais,
    c.nombre || ' ' || c.apellido AS nombre_cliente
FROM
    REMESA r
JOIN 
    EMPRESA_REMESA e ON r.id_empresa_remesa = e.id_empresa_remesa
JOIN
    CLIENTE c ON r.id_cliente = c.id_cliente;



CREATE OR REPLACE PROCEDURE sp_comming_money_by_client(
    p_id_cliente IN CLIENTE.id_cliente%TYPE
) AS
    v_cliente_existe INTEGER;
    v_remesas_count INTEGER := 0;
BEGIN
    -- Verificar si el cliente existe
    SELECT COUNT(*)
    INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;

    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error: El cliente con ID ' || p_id_cliente || ' no existe.');
    END IF;

    -- Mostrar las remesas del cliente
    DBMS_OUTPUT.PUT_LINE('Remesas para el cliente ID: ' || p_id_cliente);
    DBMS_OUTPUT.PUT_LINE('----------------------------------------');
    
    FOR r IN (
        SELECT id_remesa, empresa_remesa, monto, fecha, pais 
        FROM v_remesas_cliente 
        WHERE id_cliente = p_id_cliente
        ORDER BY fecha DESC
    ) LOOP
        DBMS_OUTPUT.PUT_LINE(
            'ID: ' || RPAD(r.id_remesa, 10) || 
            ' | Empresa: ' || RPAD(r.empresa_remesa, 20) || 
            ' | Monto: ' || RPAD(r.monto, 10) ||
            ' | Fecha: ' || TO_CHAR(r.fecha, 'DD/MM/YYYY HH24:MI:SS') ||
            ' | País: ' || r.pais
        );
        v_remesas_count := v_remesas_count + 1;
    END LOOP;
    
    -- Mostrar mensaje si no hay remesas
    IF v_remesas_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('El cliente no tiene remesas.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('----------------------------------------');
        DBMS_OUTPUT.PUT_LINE('Total remesas: ' || v_remesas_count);
    END IF;
END sp_comming_money_by_client;
/


CREATE OR REPLACE PROCEDURE sp_get_product_service(
    p_id_tipo_producto IN INTEGER,
    p_tipo_pago IN INTEGER,
    p_id_tarjeta IN INTEGER DEFAULT NULL,
    p_id_cuenta IN INTEGER DEFAULT NULL,
    p_id_prestamo IN INTEGER DEFAULT NULL,
    p_id_seguro IN INTEGER DEFAULT NULL,
    p_id_pago_tarjeta IN INTEGER DEFAULT NULL,
    p_descripcion IN VARCHAR2,
    p_monto IN NUMBER DEFAULT NULL,
    pd_id_cliente IN INTEGER
)
IS
    v_tipo_pago_existe NUMBER;
    v_tarjeta_existe NUMBER;
    v_cuenta_existe NUMBER;
    v_prestamo_existe NUMBER;
    v_seguro_existe NUMBER;
    v_pago_tarjeta_existe NUMBER;
    v_resultado Varchar2(200);
    v_monto NUMBER;

BEGIN
    --Consideraciones para el procedimiento:
    /*
        Existen 2 servicios de pago de servicios y de productos:
        1. Pago de servicios (tipo_pago = 1): Se refiere a pagos de servicios como agua, luz, pago de tarrjeta, seguro o prestamos
        2. Pago de productos (tipo_pago = 2): Se refiere a pagos de productos como tarjeta de debito, tarjeta de credito o cuenta de chequera

        Ambos se pueden pagar con tarjeta o cuenta, verificar que el id_tarjeta o id_cuenta no sean nulos, debe haber al menos uno de los dos

        No puedo pagar una tarjeta con la misma tarjeta, por lo que el id_pago_tarjeta no puede ser igual al id_tarjeta

        Si pago un prestamo, debo de modiicar la tabla de prestamos, si pago un seguro, debo de modificar la tabla de seguros, si pago una tarjeta, debo de modificar la tabla de tarjetas.

        EN NINGUN CASO MODIFICARE LA TABLA CUENTAS, PARA ELLO DEBO DE HACER UNA TRANSACCIÓN
    */

    --Paso 1, validar datos

    --Si monto es nulo para el tipo de pago 2, asignar el monto del tipo de pago
    IF p_tipo_pago = 2 AND p_monto IS NULL THEN
        SELECT monto_quetzales INTO v_monto FROM TIPO_PAGO WHERE id_tipo_producto = p_id_tipo_producto;
    ELSE
        v_monto := p_monto;
    END IF;

    --Si el tipo_pago es 1, monto es obligatorio, si es 2, monto es opcional
    IF p_tipo_pago = 1 AND p_monto IS NULL THEN
        RAISE_APPLICATION_ERROR(-20045, 'Error: El monto es obligatorio para el pago de productos');
    END IF;

    --Si p_monto no es nulo, verificar que el monto sea mayor a 0
    IF p_monto IS NOT NULL AND p_monto <= 0 THEN
        RAISE_APPLICATION_ERROR(-20046, 'Error: El monto debe ser mayor a 0');
    END IF;


    -- Validar que el tipo de pago exista
    SELECT COUNT(*) INTO v_tipo_pago_existe FROM TIPO_PAGO WHERE id_tipo_producto = p_id_tipo_producto;
    IF v_tipo_pago_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20040, 'Error: El tipo de pago especificado no existe');
    END IF;

    -- Validar que el id_tarjeta no sea igual al id_pago_tarjeta
    IF p_id_tarjeta = p_id_pago_tarjeta THEN
        RAISE_APPLICATION_ERROR(-20041, 'Error: No se puede pagar una tarjeta con la misma tarjeta');
    END IF;

    --Verificar si el pago se va a realizar con tarjeta o cuenta, al menos uno de los dos debe ser diferente de nulo
    IF p_id_tarjeta IS NULL AND p_id_cuenta IS NULL THEN
        RAISE_APPLICATION_ERROR(-20042, 'Error: Debe especificar al menos una tarjeta o cuenta para el pago');
    END IF;

    -- Validar que el id_tarjeta exista y sea del cliente
    IF p_id_tarjeta IS NOT NULL THEN
        SELECT COUNT(*) INTO v_tarjeta_existe FROM TARJETA WHERE id_tarjeta = p_id_tarjeta AND id_cliente = pd_id_cliente;
        IF v_tarjeta_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20042, 'Error: La tarjeta especificada no existe o no pertenece al cliente');
        END IF;
    END IF;

    -- Validar que el id_cuenta exista y sea del cliente
    IF p_id_cuenta IS NOT NULL THEN
        SELECT COUNT(*) INTO v_cuenta_existe FROM CUENTA WHERE id_cuenta = p_id_cuenta AND id_cliente = pd_id_cliente;
        IF v_cuenta_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20042, 'Error: La cuenta especificada no existe o no pertenece al cliente');
        END IF;
    END IF;

    --Validar que solo se haya ingresado uno de los dos, tarjeta o cuenta
    IF p_id_tarjeta IS NOT NULL AND p_id_cuenta IS NOT NULL THEN
        RAISE_APPLICATION_ERROR(-20042, 'Error: Solo se puede especificar una tarjeta o cuenta para el pago');
    END IF;

    -- Verificar que el metodo usado tenga el saldo suficiente para realizar el pago
    IF p_id_tarjeta IS NOT NULL THEN
        SELECT saldo_tarjeta INTO v_pago_tarjeta_existe FROM TARJETA WHERE id_tarjeta = p_id_tarjeta;
        IF v_pago_tarjeta_existe < v_monto THEN
            RAISE_APPLICATION_ERROR(-20043, 'Error: La tarjeta no tiene saldo suficiente para realizar el pago');
        END IF;
    ELSIF p_id_cuenta IS NOT NULL THEN
        SELECT saldo_cuenta INTO v_pago_tarjeta_existe FROM CUENTA WHERE id_cuenta = p_id_cuenta;
        IF v_pago_tarjeta_existe < v_monto THEN
            RAISE_APPLICATION_ERROR(-20044, 'Error: La cuenta no tiene saldo suficiente para realizar el pago');
        END IF;
    END IF;



    


    -- Caso 1: Pago de productos (tipo_pago = 1)
    IF p_tipo_pago = 1 THEN
        -- Dentro del caso de pago de productos, id_tipo_pago puede ser 1 pago de energía eléctrica, 2 pago de agua potable, 3 pago de matrícula USAC, 4 pago de curso de vacaciones USAC, 5 pago de seguro, 6 pago de tarjeta, 7 pago de préstamo
        -- En cada caso, validar que el id_pago_tarjeta, id_prestamo o id_seguro no sean nulos, dependiendo del tipo de pago
        -- Caso 1.5: Pago de seguro (id_seguro)
        IF p_id_tipo_producto = 5 THEN

            IF p_id_seguro IS NULL THEN
                RAISE_APPLICATION_ERROR(-20045, 'Error: El id_seguro no puede ser nulo para el pago de seguro');
            END IF;

            --Los demás campos que se podrían pagar deben ser nulos
            IF  p_id_prestamo IS NOT NULL OR p_id_pago_tarjeta IS NOT NULL THEN
            RAISE_APPLICATION_ERROR(-20052, 'Error: Para el pago de productos, los campos id_prestamo, id_pago_tarjeta y id_seguro deben ser nulos');
            END IF;
            

            -- Validar que el id_seguro exista
            SELECT COUNT(*) INTO v_seguro_existe FROM SEGURO WHERE id_seguro = p_id_seguro;
            IF v_seguro_existe = 0 THEN
                RAISE_APPLICATION_ERROR(-20046, 'Error: El seguro especificado no existe');
            END IF;

            -- Verificamos que el monto a pagar sea igual al valor_seguro de la tabla seguro
            SELECT COUNT(*) INTO v_seguro_existe FROM SEGURO WHERE id_seguro = p_id_seguro AND valor_seguro = p_monto;
            IF v_seguro_existe = 0 THEN
                RAISE_APPLICATION_ERROR(-20047, 'Error: El monto a pagar no es igual al valor del seguro');
            END IF;

            -- Actualizar el saldo del seguro
            UPDATE SEGURO SET cantidad_pagos = cantidad_pagos + 1, meses_asegurados = meses_asegurados + 12 WHERE id_seguro = p_id_seguro;

        ELSIF p_id_tipo_producto = 6 THEN
            -- Caso 1.6: Pago de tarjeta (id_pago_tarjeta)
            IF p_id_pago_tarjeta IS NULL THEN
                RAISE_APPLICATION_ERROR(-20048, 'Error: El id_pago_tarjeta no puede ser nulo para el pago de tarjeta');
            END IF;
            
            --Si la tarjeta es de debito, damos un error
            SELECT COUNT(*) INTO v_pago_tarjeta_existe FROM TARJETA WHERE id_tarjeta = p_id_pago_tarjeta AND id_tipo = 'D';
            IF v_pago_tarjeta_existe > 0 THEN
                RAISE_APPLICATION_ERROR(-20050, 'Error: No se puede pagar una tarjeta de debito');
            END IF;


            IF  p_id_prestamo IS NOT NULL OR p_id_seguro IS NOT NULL THEN
            RAISE_APPLICATION_ERROR(-20052, 'Error: Para el pago de productos, los campos id_prestamo, id_pago_tarjeta y id_seguro deben ser nulos');
            END IF;

            -- Validar que el id_pago_tarjeta exista
            SELECT COUNT(*) INTO v_pago_tarjeta_existe FROM TARJETA WHERE id_tarjeta = p_id_pago_tarjeta;
            IF v_pago_tarjeta_existe = 0 THEN
                RAISE_APPLICATION_ERROR(-20049, 'Error: La tarjeta especificada no existe');
            END IF;

            -- Si la tarjeta existe, entonces actualizamos el saldo de la tarjeta
            sp_pagar_tarjeta(
                p_id_tarjeta => p_id_pago_tarjeta,
                p_monto => p_monto
            );

        ELSIF p_id_tipo_producto = 7 THEN
            -- Caso 1.7: Pago de préstamo (id_prestamo)
            IF p_id_prestamo IS NULL THEN
                RAISE_APPLICATION_ERROR(-20050, 'Error: El id_prestamo no puede ser nulo para el pago de préstamo');
            END IF;

            IF  p_id_seguro IS NOT NULL OR p_id_pago_tarjeta IS NOT NULL THEN
            RAISE_APPLICATION_ERROR(-20052, 'Error: Para el pago de productos, los campos id_prestamo, id_pago_tarjeta y id_seguro deben ser nulos');
            END IF;
            -- Validar que el id_prestamo exista
            SELECT COUNT(*) INTO v_prestamo_existe FROM PRESTAMO WHERE id_prestamo = p_id_prestamo;
            IF v_prestamo_existe = 0 THEN
                RAISE_APPLICATION_ERROR(-20051, 'Error: El préstamo especificado no existe');
            END IF;

            --LLamamos a la función de pago de préstamo fn_pagar_proxima_cuota(p_id_prestamo, fecha, p_monto)
            v_resultado := fn_pagar_proxima_cuota(p_id_prestamo, SYSDATE, p_monto);
            DBMS_OUTPUT.PUT_LINE(v_resultado);
            

        ELSE

        --Para todos los demás casos, validar que el id_pago_tarjeta, id_prestamo o id_seguro sean nulos
            IF  p_id_pago_tarjeta IS NOT NULL OR p_id_prestamo IS NOT NULL OR p_id_seguro IS NOT NULL THEN
                RAISE_APPLICATION_ERROR(-20052, 'Error: Para el tipo de producto ingresado, los campos id_prestamo, id_pago_tarjeta y id_seguro deben ser nulos');
            END IF;

        END IF;
    -- Caso 2: Pago de productos (tipo_pago = 2)
        -- En este caso se le pagar al banco por lo que no hay que hacer ninguna operación adicional. Unicamente verificar que los demas campos sean nulos
    ELSIF p_tipo_pago = 2 THEN
        -- Validar que el id_tarjeta, id_cuenta, id_prestamo y id_seguro sean nulos
        IF  p_id_prestamo IS NOT NULL OR p_id_seguro IS NOT NULL OR p_id_pago_tarjeta IS NOT NULL THEN
            RAISE_APPLICATION_ERROR(-20052, 'Error: Para el pago de productos, los campos id_prestamo, id_pago_tarjeta y id_seguro deben ser nulos');
        END IF;

    END IF;

    -- Paso 2: Insertar el pago en la tabla PAGO_PRODUCTO_SERVICIO
    INSERT INTO PAGO_PRODUCTO_SERVICIO (
        id_tipo_pago,
        tipo_pago,
        id_tarjeta,
        id_cliente,
        id_cuenta,
        id_prestamo,
        id_seguro,
        id_pago_tarjeta,
        descripcion,
        monto
    ) VALUES (
        p_id_tipo_producto,
        p_tipo_pago,
        p_id_tarjeta,
        pd_id_cliente,
        p_id_cuenta,
        p_id_prestamo,
        p_id_seguro,
        p_id_pago_tarjeta,
        p_descripcion,
        v_monto
    );


    COMMIT; -- Confirmar la transacción


    DBMS_OUTPUT.PUT_LINE('Pago realizado con éxito. Realice la transaccion correspondiente para el pago de productos.');


EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK; -- Deshacer la transacción en caso de error
        RAISE_APPLICATION_ERROR(-20053, 'Error: Ocurrió un error al procesar el pago: ' || SQLERRM);
END sp_get_product_service;
/

CREATE OR REPLACE VIEW v_productos_cliente AS
SELECT 
    p.id_pago_producto_servicio,
    p.id_cliente,
    c.nombre || ' ' || c.apellido AS nombre_cliente,
    tp.nombre AS tipo_producto,
    CASE 
        WHEN p.tipo_pago = 1 THEN 'Pago de servicio'
        WHEN p.tipo_pago = 2 THEN 'Producto bancario'
        ELSE 'Otro'
    END AS categoria,
    p.monto,
    CASE 
        WHEN p.id_cuenta IS NOT NULL THEN 'Cuenta: ' || p.id_cuenta
        WHEN p.id_tarjeta IS NOT NULL THEN 'Tarjeta: ' || t.numero_tarjeta
        WHEN p.id_prestamo IS NOT NULL THEN 'Préstamo: ' || pr.id_prestamo
        WHEN p.id_seguro IS NOT NULL THEN 'Seguro: ' || s.id_seguro
        ELSE 'N/A'
    END AS producto_asociado,
    p.descripcion,
    TO_CHAR(p.created_at, 'DD/MM/YYYY HH24:MI') AS fecha_creacion,
    -- Campos específicos por tipo de producto
    tp.monto_quetzales,
    tp.monto_dolares,
    p.id_tipo_pago,
    p.tipo_pago
FROM 
    PAGO_PRODUCTO_SERVICIO p
    JOIN CLIENTE c ON p.id_cliente = c.id_cliente
    JOIN TIPO_PAGO tp ON p.id_tipo_pago = tp.id_tipo_producto
    LEFT JOIN CUENTA cu ON p.id_cuenta = cu.id_cuenta
    LEFT JOIN TARJETA t ON p.id_tarjeta = t.id_tarjeta OR p.id_pago_tarjeta = t.id_tarjeta
    LEFT JOIN PRESTAMO pr ON p.id_prestamo = pr.id_prestamo
    LEFT JOIN SEGURO s ON p.id_seguro = s.id_seguro;

CREATE OR REPLACE PROCEDURE sp_products_by_client(
   p_id_cliente IN CLIENTE.id_cliente%TYPE
) AS
    v_cliente_existe INTEGER;
    v_productos_count INTEGER := 0;
BEGIN
    -- Verificar si el cliente existe
    SELECT COUNT(*) INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;

    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error: El cliente con ID ' || p_id_cliente || ' no existe.');
    END IF;

    -- Activar salida de datos
    DBMS_OUTPUT.PUT_LINE('PRODUCTOS Y SERVICIOS DEL CLIENTE ID: ' || p_id_cliente);
    DBMS_OUTPUT.PUT_LINE('===================================================');
    DBMS_OUTPUT.PUT_LINE(
        RPAD('ID', 8) || 
        RPAD('TIPO PRODUCTO', 30) || 
        RPAD('CATEGORIA', 20) || 
        RPAD('MONTO', 15) || 
        RPAD('PRODUCTO ASOCIADO', 25) || 
        'DESCRIPCION'
    );
    DBMS_OUTPUT.PUT_LINE('===================================================');
    
    -- Mostrar productos del cliente
    FOR r IN (
        SELECT 
            id_pago_producto_servicio,
            tipo_producto,
            categoria,
            monto AS monto_formateado,
            producto_asociado,
            descripcion
        FROM 
            v_productos_cliente
        WHERE 
            id_cliente = p_id_cliente
        ORDER BY 
            fecha_creacion DESC
    ) LOOP
        DBMS_OUTPUT.PUT_LINE(
            RPAD(r.id_pago_producto_servicio, 8) || 
            RPAD(r.tipo_producto, 30) || 
            RPAD(r.categoria, 20) || 
            RPAD(r.monto_formateado, 15) || 
            RPAD(NVL(r.producto_asociado, 'N/A'), 25) || 
            NVL(r.descripcion, '')
        );
        v_productos_count := v_productos_count + 1;
    END LOOP;
    
    -- Mostrar resumen
    DBMS_OUTPUT.PUT_LINE('===================================================');
    IF v_productos_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('El cliente no tiene productos o servicios asociados.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Total productos/servicios: ' || v_productos_count);
    END IF;
    
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
        RAISE;
END sp_products_by_client;
/


CREATE OR REPLACE PROCEDURE sp_transaction(
    p_id_tipo_transaccion IN INTEGER,
    p_fecha_transaccion IN TIMESTAMP,
    p_otros_detalles IN VARCHAR2 DEFAULT NULL,
    p_id_cliente IN INTEGER,
    p_id_cuenta IN INTEGER DEFAULT NULL,
    p_id_tarjeta IN INTEGER DEFAULT NULL,
    p_valor IN NUMBER,
    p_id_cuenta_origen IN INTEGER DEFAULT NULL,
    p_id_cuenta_destino IN INTEGER DEFAULT NULL
)
IS
    v_cliente_existe INTEGER;
    v_cuenta_existe INTEGER;
    v_tarjeta_existe INTEGER;
    v_tipo_transaccion_existe INTEGER;
    v_monto_suficiente INTEGER;

BEGIN


/*
Tipos de transacciones
Tipo 1: Débito, se quita dinero de la cuenta y se agrega a otra cuenta
campos obligatorios:
id_tipo_transacción
fecha_transacción
id_cliente
id_cuenta_origen
id_cuenta_destino
valor (monto a transferir)

Tipo 2: Crédito, se agrega dinero a la cuenta, el dinero se supone que viene de fuera
campos obligatorios:
id_tipo_transacción
fecha_transacción
id_cliente
id_cuenta
valor (monto a agregar)

Tipo 3: Consumo con tarjeta, se resta del saldo de la tarjeta (pago con tarjeta de crédito o débito)
campos obligatorios:
id_tipo_transacción
fecha_transacción
id_cliente
id_tarjeta
valor (monto a consumir restar de la tarjeta)

Tipo 4: Remesa, se agrega dinero a la cuenta, el dinero se supone que viene de fuera
campos obligatorios
id_tipo_transacción
fecha_transacción
id_cliente
id_cuenta
valor (monto a agregar)

tipo 5: Pago de servicio/producto, se resta del saldo de la tarjeta o de la cuenta (puede ser cualquiera de las dos)
campos obligatorios:
id_tipo_transacción
fecha_transacción
id_cliente
id_cuenta o id_tarjeta (uno de los dos)
valor (monto a pagar)
cuenta_destino (cuenta a la que se le va a pagar el servicio)
*/


/*
Validaciones:
En débito verificar que la cuenta origen pertenezca al cliente
En crédito verificar que la cuenta pertenezca al cliente
En consumo verificar que la tarjeta pertenezca al cliente
En remesa verificar que la cuenta pertenezca al cliente
En pago de servicio verificar que la cuenta o tarjeta pertenezca al cliente

Siempre verificar que el monto a pagar sea positivo y que la cuenta origen tenga suficiente saldo

*/

/*Validaciones obligatorias
1. que el cliente exista
2. Que las cuentas involucradas existan
3. Que la tarjeta exista
4. Que el tipo de transacción exista
5. Que el monto a pagar sea positivo
6. Que la cuenta origen tenga suficiente saldo (si aplica)
7. Que la cuenta destino exista (si aplica)
9. Fecha valida (no puede ser mayor a la fecha actual)
*/

   --Validaciones globales, iguales en todos los casos. id_cliente, fecha_transaccion, id_tipo_transaccion, valor. Siempre obligatorios y deben cumplir con las validaciones

    --Validar que el cliente exista
    SELECT COUNT(*)
    INTO v_cliente_existe
    FROM CLIENTE
    WHERE id_cliente = p_id_cliente;
    
    IF v_cliente_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error: El cliente no existe');
    END IF;


    --Validar que el tipo de transacción exista
    SELECT COUNT(*)
    INTO v_tipo_transaccion_existe
    FROM TIPO_TRANSACCION
    WHERE id_tipo_transaccion = p_id_tipo_transaccion;

    IF v_tipo_transaccion_existe = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Error: El tipo de transacción no existe');
    END IF;


    --Validar que el monto a pagar sea positivo
    IF p_valor <= 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'Error: El monto a pagar debe ser positivo');
    END IF;


    --Validar que la fecha de transacción no sea mayor a la fecha actual
    IF p_fecha_transaccion > SYSTIMESTAMP THEN
        RAISE_APPLICATION_ERROR(-20004, 'Error: La fecha de transacción no puede ser mayor a la fecha actual');
    END IF;

    --Iniciamos con el tipo de transacción en especifco. Usamos una estructura CASE

    CASE p_id_tipo_transaccion
        --Tipo 1: Débito, se quita dinero de la cuenta y se agrega a otra cuenta
        WHEN 1 THEN
            --Validar que la cuenta origen pertenezca al cliente
            SELECT COUNT(*)
            INTO v_cuenta_existe
            FROM CUENTA
            WHERE id_cuenta = p_id_cuenta_origen AND id_cliente = p_id_cliente;
            
            IF v_cuenta_existe = 0 THEN
                RAISE_APPLICATION_ERROR(-20005, 'Error: La cuenta origen no pertenece al cliente');
            END IF;

            --No se requiere que la cuenta destino pertenezca al cliente, ya que puede ser una cuenta de otra persona
            --Validar que la cuenta destino exista
            SELECT COUNT(*)
            INTO v_cuenta_existe
            FROM CUENTA
            WHERE id_cuenta = p_id_cuenta_destino;

            IF v_cuenta_existe = 0 THEN
                RAISE_APPLICATION_ERROR(-20006, 'Error: La cuenta destino no existe');
            END IF;

            --Validar que la cuenta origen tenga suficiente saldo
            SELECT COUNT(*)
            INTO v_monto_suficiente
            FROM CUENTA
            WHERE id_cuenta = p_id_cuenta_origen AND saldo_cuenta >= p_valor;


            IF v_monto_suficiente = 0 THEN
                RAISE_APPLICATION_ERROR(-20007, 'Error: La cuenta origen no tiene suficiente saldo');
            END IF;


            --Insertar la transacción
            INSERT INTO TRANSACCION (
                id_tipo_transaccion,
                fecha_transaccion,
                otros_detalles,
                id_cliente,
                id_cuenta_origen,
                id_cuenta_destino,
                valor
            ) VALUES (
                p_id_tipo_transaccion,
                p_fecha_transaccion,
                p_otros_detalles,
                p_id_cliente,
                p_id_cuenta_origen,
                p_id_cuenta_destino,
                p_valor
            );

            --Actualizar el saldo de la cuenta origen y destino
            UPDATE CUENTA
            SET saldo_cuenta = saldo_cuenta - p_valor
            WHERE id_cuenta = p_id_cuenta_origen;

            UPDATE CUENTA
            SET saldo_cuenta = saldo_cuenta + p_valor
            WHERE id_cuenta = p_id_cuenta_destino;
            
            p_actualizar_tarjetas_por_cuenta(p_id_cuenta_destino);
            p_actualizar_tarjetas_por_cuenta(p_id_cuenta_origen);
            --Finalizar y mostrar mensaje OK
            COMMIT;

        WHEN 2 THEN
            --Tipo 2: Crédito, se agrega dinero a la cuenta, el dinero se supone que viene de fuera
            --Validar que la cuenta pertenezca al cliente
            SELECT COUNT(*)
            INTO v_cuenta_existe
            FROM CUENTA
            WHERE id_cuenta = p_id_cuenta AND id_cliente = p_id_cliente;
            
            IF v_cuenta_existe = 0 THEN
                RAISE_APPLICATION_ERROR(-20008, 'Error: La cuenta no pertenece al cliente');
            END IF;

            --Insertar la transacción
            INSERT INTO TRANSACCION (
                id_tipo_transaccion,
                fecha_transaccion,
                otros_detalles,
                id_cliente,
                id_cuenta,
                valor
            ) VALUES (
                p_id_tipo_transaccion,
                p_fecha_transaccion,
                p_otros_detalles,
                p_id_cliente,
                p_id_cuenta,
                p_valor
            );

            --Actualizar el saldo de la cuenta
            UPDATE CUENTA
            SET saldo_cuenta = saldo_cuenta + p_valor
            WHERE id_cuenta = p_id_cuenta;
            
            p_actualizar_tarjetas_por_cuenta(p_id_cuenta);


            --Finalizar y mostrar mensaje OK
            COMMIT;

        WHEN 3 THEN
            --Tipo 3: Consumo con tarjeta, se resta del saldo de la tarjeta (pago con tarjeta de crédito o débito)
            --Validar que la tarjeta pertenezca al cliente
            SELECT COUNT(*)
            INTO v_tarjeta_existe
            FROM TARJETA
            WHERE id_tarjeta = p_id_tarjeta AND id_cliente = p_id_cliente;
            
            IF v_tarjeta_existe = 0 THEN
                RAISE_APPLICATION_ERROR(-20009, 'Error: La tarjeta no pertenece al cliente');
            END IF;

            --Validar que la tarjeta tenga suficiente saldo
            SELECT COUNT(*)
            INTO v_monto_suficiente
            FROM TARJETA
            WHERE id_tarjeta = p_id_tarjeta AND saldo_tarjeta >= p_valor;


            IF v_monto_suficiente = 0 THEN
                RAISE_APPLICATION_ERROR(-20010, 'Error: La tarjeta no tiene suficiente saldo');
            END IF;

            --Insertar la transacción
            INSERT INTO TRANSACCION (
                id_tipo_transaccion,
                fecha_transaccion,
                otros_detalles,
                id_cliente,
                id_tarjeta,
                valor
            ) VALUES (
                p_id_tipo_transaccion,
                p_fecha_transaccion,
                p_otros_detalles,
                p_id_cliente,
                p_id_tarjeta,
                p_valor
            );


            --Actualizar el saldo de la tarjeta
            UPDATE TARJETA
            SET saldo_tarjeta = saldo_tarjeta - p_valor
            WHERE id_tarjeta = p_id_tarjeta;

            --Si la tarjeta es de debito, actualizar el saldo de la cuenta asociada a la tarjeta
            p_actualizar_cuenta_por_tarjeta(p_id_tarjeta, p_valor);
            


            --Finalizar y mostrar mensaje OK
            COMMIT;

        WHEN 4 THEN
            --Tipo 4: Remesa, se agrega dinero a la cuenta, el dinero se supone que viene de fuera
            --Validar que la cuenta pertenezca al cliente
            SELECT COUNT(*)
            INTO v_cuenta_existe
            FROM CUENTA
            WHERE id_cuenta = p_id_cuenta AND id_cliente = p_id_cliente;
            
            IF v_cuenta_existe = 0 THEN
                RAISE_APPLICATION_ERROR(-20011, 'Error: La cuenta no pertenece al cliente');
            END IF;

            --Insertar la transacción
            INSERT INTO TRANSACCION (
                id_tipo_transaccion,
                fecha_transaccion,
                otros_detalles,
                id_cliente,
                id_cuenta,
                valor
            ) VALUES (
                p_id_tipo_transaccion,
                p_fecha_transaccion,
                p_otros_detalles,
                p_id_cliente,
                p_id_cuenta,
                p_valor
            );

            --Actualizar el saldo de la cuenta
            UPDATE CUENTA
            SET saldo_cuenta = saldo_cuenta + p_valor
            WHERE id_cuenta = p_id_cuenta;
            
            p_actualizar_tarjetas_por_cuenta(p_id_cuenta);


            --Finalizar y mostrar mensaje OK
            COMMIT;


        WHEN 5 THEN
            --Tipo 5: Pago de servicio/producto, se resta del saldo de la tarjeta o de la cuenta (puede ser cualquiera de las dos)
            --Validar que la cuenta o tarjeta pertenezca al cliente
            --Solo debe haber 1 de los dos, si hay los dos, damos error
            IF p_id_cuenta IS NOT NULL AND p_id_tarjeta IS NOT NULL THEN
                RAISE_APPLICATION_ERROR(-20012, 'Error: Solo se puede usar una cuenta o una tarjeta para el pago');
            END IF;

            --Cuenta destino es obligatoria, no puede ser nula
            IF p_id_cuenta_destino IS NULL THEN
                RAISE_APPLICATION_ERROR(-20012, 'Error: La cuenta destino es obligatoria');
            END IF;

            -- Opcion 1: Pago con tarjeta
            IF p_id_tarjeta IS NOT NULL THEN
                --Validar que la tarjeta pertenezca al cliente
                SELECT COUNT(*)
                INTO v_tarjeta_existe
                FROM TARJETA
                WHERE id_tarjeta = p_id_tarjeta AND id_cliente = p_id_cliente;
                
                IF v_tarjeta_existe = 0 THEN
                    RAISE_APPLICATION_ERROR(-20013, 'Error: La tarjeta no pertenece al cliente');
                END IF;

                --Validar que la tarjeta tenga suficiente saldo
                SELECT COUNT(*)
                INTO v_monto_suficiente
                FROM TARJETA
                WHERE id_tarjeta = p_id_tarjeta AND saldo_tarjeta >= p_valor;


                IF v_monto_suficiente = 0 THEN
                    RAISE_APPLICATION_ERROR(-20014, 'Error: La tarjeta no tiene suficiente saldo');
                END IF;

                -- Veriificar que la cuenta destino exista
                SELECT COUNT(*)
                INTO v_cuenta_existe
                FROM CUENTA
                WHERE id_cuenta = p_id_cuenta_destino;

                IF v_cuenta_existe = 0 THEN
                    RAISE_APPLICATION_ERROR(-20015, 'Error: La cuenta destino no existe');
                END IF;

                --Realizar la transacción
                INSERT INTO TRANSACCION (
                    id_tipo_transaccion,
                    fecha_transaccion,
                    otros_detalles,
                    id_cliente,
                    id_tarjeta,
                    valor,
                    id_cuenta_destino
                ) VALUES (
                    p_id_tipo_transaccion,
                    p_fecha_transaccion,
                    p_otros_detalles,
                    p_id_cliente,
                    p_id_tarjeta,
                    p_valor,
                    p_id_cuenta_destino
                );

                --Actualizar el saldo de la tarjeta
                UPDATE TARJETA
                SET saldo_tarjeta = saldo_tarjeta - p_valor
                WHERE id_tarjeta = p_id_tarjeta;

                --Actualizar el saldo de la cuenta destino
                UPDATE CUENTA
                SET saldo_cuenta = saldo_cuenta + p_valor
                WHERE id_cuenta = p_id_cuenta_destino;
                
                p_actualizar_tarjetas_por_cuenta(p_id_cuenta_destino);
                p_actualizar_cuenta_por_tarjeta(p_id_tarjeta, p_valor);
                


                --Finalizar y mostrar mensaje OK
                COMMIT;
            END IF;

            -- Opcion 2: Pago con cuenta

            IF p_id_cuenta IS NOT NULL THEN
                --Validar que la cuenta pertenezca al cliente
                SELECT COUNT(*)
                INTO v_cuenta_existe
                FROM CUENTA
                WHERE id_cuenta = p_id_cuenta AND id_cliente = p_id_cliente;
                
                IF v_cuenta_existe = 0 THEN
                    RAISE_APPLICATION_ERROR(-20016, 'Error: La cuenta no pertenece al cliente');
                END IF;

                --Validar que la cuenta tenga suficiente saldo
                SELECT COUNT(*)
                INTO v_monto_suficiente
                FROM CUENTA
                WHERE id_cuenta = p_id_cuenta AND saldo_cuenta >= p_valor;


                IF v_monto_suficiente = 0 THEN
                    RAISE_APPLICATION_ERROR(-20017, 'Error: La cuenta no tiene suficiente saldo');
                END IF;

                -- Veriificar que la cuenta destino exista
                SELECT COUNT(*)
                INTO v_cuenta_existe
                FROM CUENTA
                WHERE id_cuenta = p_id_cuenta_destino;

                IF v_cuenta_existe = 0 THEN
                    RAISE_APPLICATION_ERROR(-20018, 'Error: La cuenta destino no existe');
                END IF;

                --Realizar la transacción
                INSERT INTO TRANSACCION (
                    id_tipo_transaccion,
                    fecha_transaccion,
                    otros_detalles,
                    id_cliente,
                    id_cuenta,
                    valor,
                    id_cuenta_destino
                ) VALUES (
                    p_id_tipo_transaccion,
                    p_fecha_transaccion,
                    p_otros_detalles,
                    p_id_cliente,
                    p_id_cuenta,
                    p_valor,
                    p_id_cuenta_destino
                );

                --Actualizar el saldo de la cuenta
                UPDATE CUENTA
                SET saldo_cuenta = saldo_cuenta - p_valor
                WHERE id_cuenta = p_id_cuenta;

                --Actualizar el saldo de la cuenta destino
                UPDATE CUENTA
                SET saldo_cuenta = saldo_cuenta + p_valor
                WHERE id_cuenta = p_id_cuenta_destino;
                
                p_actualizar_tarjetas_por_cuenta(p_id_cuenta);
                p_actualizar_tarjetas_por_cuenta(p_id_cuenta_destino);

                --Finalizar y mostrar mensaje OK
                COMMIT;
            END IF;

        ELSE
            RAISE_APPLICATION_ERROR(-20019, 'Error: Tipo de transacción no válida');
        END CASE;


    DBMS_OUTPUT.PUT_LINE('Transaccion realizada con exito');

EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE('Error al crear la transacción: ' || SQLERRM);
    END sp_transaction;
/

CREATE OR REPLACE VIEW v_transacciones_clientes AS
SELECT 
    t.id_cliente,
    t.id_transaccion,
    tt.nombre AS tipo_transaccion,
    t.fecha_transaccion,
    t.valor,
    c.nombre || ' ' || c.apellido AS cliente,
    tc.nombre AS tipo_cuenta,
    CASE 
        WHEN t.id_cuenta_origen IS NOT NULL AND t.id_cuenta_destino IS NOT NULL 
            THEN 'Transferencia entre cuentas'
        WHEN t.id_cuenta_origen IS NOT NULL 
            THEN 'Débito desde cuenta'
        WHEN t.id_cuenta_destino IS NOT NULL 
            THEN 'Crédito a cuenta'
        ELSE 'Transacción directa'
    END AS descripcion_operacion,
    t.otros_detalles,
    t.id_cuenta_origen,
    t.id_cuenta_destino,
    t.id_tarjeta,
    t.id_cuenta
FROM 
    TRANSACCION t
JOIN 
    TIPO_TRANSACCION tt ON t.id_tipo_transaccion = tt.id_tipo_transaccion
JOIN 
    CLIENTE c ON t.id_cliente = c.id_cliente
LEFT JOIN 
    CUENTA cu ON t.id_cuenta = cu.id_cuenta
LEFT JOIN 
    TIPO_CUENTA tc ON cu.tipo_cuenta = tc.id_tipo_cuenta
ORDER BY 
    t.fecha_transaccion DESC;
    
    
CREATE OR REPLACE PROCEDURE sp_transactions_by_client(
    p_id_cliente IN INTEGER DEFAULT NULL,
    p_fecha_inicio IN DATE DEFAULT NULL,
    p_fecha_fin IN DATE DEFAULT NULL,
    p_tipo_transaccion IN VARCHAR2 DEFAULT NULL
) IS
    v_has_results BOOLEAN := FALSE;
    v_total_valor NUMBER := 0;
BEGIN
    -- Validación de fechas si se proporcionan ambas
    IF p_fecha_inicio IS NOT NULL AND p_fecha_fin IS NOT NULL THEN
        IF p_fecha_inicio > p_fecha_fin THEN
            RAISE_APPLICATION_ERROR(-20001, 'Error: La fecha de inicio no puede ser mayor que la fecha final');
        END IF;
    END IF;
    
    -- Encabezado del reporte
    DBMS_OUTPUT.PUT_LINE('REPORTE DE TRANSACCIONES FILTRADAS');
    DBMS_OUTPUT.PUT_LINE('----------------------------------');
    
    -- Mostrar parámetros de filtrado
    IF p_id_cliente IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE('Cliente ID: ' || p_id_cliente);
    ELSE
        DBMS_OUTPUT.PUT_LINE('Cliente: Todos');
    END IF;
    
    IF p_fecha_inicio IS NOT NULL AND p_fecha_fin IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE('Periodo: ' || TO_CHAR(p_fecha_inicio, 'DD/MM/YYYY') || 
                            ' al ' || TO_CHAR(p_fecha_fin, 'DD/MM/YYYY'));
    ELSE
        DBMS_OUTPUT.PUT_LINE('Periodo: Todos');
    END IF;
    
    IF p_tipo_transaccion IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE('Tipo de transacción: ' || p_tipo_transaccion);
    ELSE
        DBMS_OUTPUT.PUT_LINE('Tipo de transacción: Todos');
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('----------------------------------');
    DBMS_OUTPUT.PUT_LINE(
        RPAD('ID', 10) || 
        RPAD('FECHA', 15) || 
        RPAD('TIPO', 15) || 
        RPAD('VALOR', 15) || 
        RPAD('CLIENTE', 25) || 
        RPAD('OPERACION', 25) || 
        'DETALLES'
    );
    DBMS_OUTPUT.PUT_LINE('----------------------------------');
    
    -- Recorrer transacciones filtradas
    FOR trans IN (
        SELECT
            id_transaccion,
            tipo_transaccion,
            TO_CHAR(fecha_transaccion, 'DD/MM/YYYY HH24:MI') AS fecha_formateada,
            valor,
            cliente,
            descripcion_operacion,
            otros_detalles
        FROM 
            v_transacciones_clientes
        WHERE 
            id_cliente = p_id_cliente
            AND (p_fecha_inicio IS NULL OR fecha_transaccion >= TRUNC(p_fecha_inicio))
            AND (p_fecha_fin IS NULL OR fecha_transaccion <= TRUNC(p_fecha_fin) + 0.99999)
            AND (p_tipo_transaccion IS NULL OR tipo_transaccion = p_tipo_transaccion)
        ORDER BY 
            fecha_transaccion DESC
    ) LOOP
        DBMS_OUTPUT.PUT_LINE(
            RPAD(trans.id_transaccion, 10) || 
            RPAD(trans.fecha_formateada, 15) || 
            RPAD(trans.tipo_transaccion, 15) || 
            RPAD(TO_CHAR(trans.valor, 'FM999G999G990D00'), 15) || 
            RPAD(trans.cliente, 25) || 
            RPAD(trans.descripcion_operacion, 25) || 
            NVL(trans.otros_detalles, '')
        );
        
        v_has_results := TRUE;
        v_total_valor := v_total_valor + trans.valor;
    END LOOP;
    
    -- Pie del reporte
    DBMS_OUTPUT.PUT_LINE('----------------------------------');
    
    IF NOT v_has_results THEN
        DBMS_OUTPUT.PUT_LINE('No se encontraron transacciones con los filtros aplicados');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Total valor de transacciones: ' || TO_CHAR(v_total_valor, 'FM999G999G990D00'));
    END IF;
    
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Error en: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END sp_transactions_by_client;
/

CREATE OR REPLACE TRIGGER trg_tarjeta_debito
BEFORE INSERT ON TARJETA
FOR EACH ROW
DECLARE
    v_saldo_cuenta CUENTA.saldo_cuenta%TYPE;
    v_cuenta_existe NUMBER;
BEGIN
    IF :NEW.id_tipo = 'D' THEN
        -- Verificar primero si existe la cuenta
        SELECT COUNT(*) INTO v_cuenta_existe
        FROM CUENTA
        WHERE id_cuenta = :NEW.id_cuenta;
        
        IF v_cuenta_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'No existe la cuenta asociada para esta tarjeta de débito.');
        END IF;
        
        -- Obtener saldo solo si la cuenta existe
        SELECT saldo_cuenta INTO v_saldo_cuenta
        FROM CUENTA
        WHERE id_cuenta = :NEW.id_cuenta
        FOR UPDATE; -- Bloquea el registro para evitar cambios concurrentes
        
        -- Validar que el saldo no sea negativo
        IF v_saldo_cuenta < 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'La cuenta asociada tiene saldo negativo. No se puede crear tarjeta.');
        END IF;
        
        -- Asignar valores
        :NEW.saldo_tarjeta := v_saldo_cuenta;
        :NEW.monto_limite := v_saldo_cuenta;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        -- Manejo adicional de errores
        RAISE_APPLICATION_ERROR(-20003, 'Error en trg_tarjeta_debito: ' || SQLERRM);
END;
/

BEGIN
    FOR rec IN (SELECT table_name
                FROM all_tab_columns
                WHERE column_name = 'UPDATED_AT'
                  AND owner = 'pruebas') -- Cambia el esquema si es necesario
    LOOP
        EXECUTE IMMEDIATE 'CREATE OR REPLACE TRIGGER trg_update_' || rec.table_name || '
                           BEFORE UPDATE ON ' || rec.table_name || '
                           FOR EACH ROW
                           BEGIN
                               :NEW.updated_at := CURRENT_TIMESTAMP;
                           END;';
    END LOOP;
END;
/

--Vistas relacionadas con prestamos
--vw_active_loans
--vw_inactive_loans
CREATE OR REPLACE VIEW vw_active_loans AS
SELECT 
    p.id_prestamo,
    p.monto_prestamo,
    p.tasa_interes,
    p.meses AS plazo_total_meses,
    p.meses_restantes,
    p.monto_restante,
    p.fecha_contratacion,
    p.fecha_vencimiento,
    c.nombre || ' ' || c.apellido AS cliente,
    CASE 
        WHEN p.fecha_vencimiento >= SYSDATE AND p.monto_restante > 0 THEN 'ACTIVO'
        WHEN p.fecha_vencimiento < SYSDATE AND p.monto_restante > 0 THEN 'VENCIDO'
        ELSE 'INACTIVO'
    END AS estado_prestamo,
    (SELECT COUNT(*) 
     FROM CUOTA_PRESTAMO cp 
     WHERE cp.id_prestamo = p.id_prestamo 
     AND cp.estado = 'PENDIENTE') AS cuotas_pendientes,
    (SELECT NVL(SUM(monto_cuota), 0)
     FROM CUOTA_PRESTAMO cp 
     WHERE cp.id_prestamo = p.id_prestamo 
     AND cp.estado = 'PENDIENTE') AS total_pendiente
FROM 
    PRESTAMO p
JOIN 
    CLIENTE c ON p.id_cliente = c.id_cliente
WHERE 
    p.monto_restante > 0
    AND p.fecha_vencimiento >= SYSDATE
ORDER BY 
    p.fecha_vencimiento;


CREATE OR REPLACE VIEW vw_inactive_loans AS
SELECT 
    p.id_prestamo,
    p.monto_prestamo,
    p.tasa_interes,
    p.meses AS plazo_total_meses,
    p.monto_restante,
    p.fecha_contratacion,
    p.fecha_vencimiento,
    c.nombre || ' ' || c.apellido AS cliente,
    CASE 
        WHEN p.monto_restante <= 0 THEN 'PAGADO COMPLETO'
        WHEN p.fecha_vencimiento < SYSDATE AND p.monto_restante > 0 THEN 'VENCIDO CON SALDO'
        ELSE 'INACTIVO'
    END AS estado_prestamo,
    (SELECT MAX(fecha_pago) 
     FROM CUOTA_PRESTAMO cp 
     WHERE cp.id_prestamo = p.id_prestamo) AS ultima_fecha_pago,
    (SELECT COUNT(*) 
     FROM CUOTA_PRESTAMO cp 
     WHERE cp.id_prestamo = p.id_prestamo 
     AND cp.estado = 'PAGADA') AS cuotas_pagadas
FROM 
    PRESTAMO p
JOIN 
    CLIENTE c ON p.id_cliente = c.id_cliente
WHERE 
    p.monto_restante <= 0
    OR p.fecha_vencimiento < SYSDATE
ORDER BY 
    CASE 
        WHEN p.monto_restante <= 0 THEN 1
        ELSE 2
    END,
    p.fecha_vencimiento DESC;

CREATE OR REPLACE VIEW vw_products AS
SELECT 
    -- Información del tipo de producto/servicio
    tp.nombre AS tipo_producto,
    CASE 
        WHEN tp.tipo = 1 THEN 'Pago de servicio'
        WHEN tp.tipo = 2 THEN 'Servicio bancario'
        ELSE 'Otro'
    END AS categoria,
    
    -- Información del producto/servicio específico
    pps.id_pago_producto_servicio,
    pps.descripcion,
    pps.monto,
    TO_CHAR(pps.created_at, 'DD/MM/YYYY HH24:MI') AS fecha_adquisicion,
    
    -- Información del medio de pago (cuenta/tarjeta)
    CASE 
        WHEN pps.id_tarjeta IS NOT NULL THEN 'Tarjeta ' || tar.numero_tarjeta
        WHEN pps.id_cuenta IS NOT NULL THEN 'Cuenta ' || pps.id_cuenta
        ELSE 'Efectivo/otro'
    END AS medio_pago,
    
    CASE 
        WHEN pps.id_tarjeta IS NOT NULL THEN 
            CASE tar.id_tipo 
                WHEN 'C' THEN 'Crédito' 
                WHEN 'D' THEN 'Débito' 
            END
        WHEN pps.id_cuenta IS NOT NULL THEN tcu.nombre
        ELSE 'N/A'
    END AS tipo_medio_pago,
    
    -- Información del cliente
    c.nombre || ' ' || c.apellido AS cliente,
    c.numero_telefono,
    c.email,
    
    -- Información del producto asociado (si aplica)
    CASE 
        WHEN pps.id_prestamo IS NOT NULL THEN 'Préstamo #' || pps.id_prestamo
        WHEN pps.id_seguro IS NOT NULL THEN 'Seguro #' || pps.id_seguro
        WHEN pps.id_pago_tarjeta IS NOT NULL THEN 'Tarjeta #' || tar_pago.numero_tarjeta
        ELSE 'N/A'
    END AS producto_asociado
FROM 
    PAGO_PRODUCTO_SERVICIO pps
JOIN 
    TIPO_PAGO tp ON pps.id_tipo_pago = tp.id_tipo_producto
JOIN 
    CLIENTE c ON pps.id_cliente = c.id_cliente
LEFT JOIN 
    TARJETA tar ON pps.id_tarjeta = tar.id_tarjeta
LEFT JOIN 
    CUENTA cu ON pps.id_cuenta = cu.id_cuenta
LEFT JOIN 
    TIPO_CUENTA tcu ON cu.tipo_cuenta = tcu.id_tipo_cuenta
LEFT JOIN 
    PRESTAMO pr ON pps.id_prestamo = pr.id_prestamo
LEFT JOIN 
    SEGURO s ON pps.id_seguro = s.id_seguro
LEFT JOIN 
    TARJETA tar_pago ON pps.id_pago_tarjeta = tar_pago.id_tarjeta;

CREATE OR REPLACE VIEW vw_active_insurances AS
SELECT 
    ts.nombre AS tipo_seguro,
    s.id_seguro,
    s.monto_asegurado,
    s.valor_seguro,
    s.cantidad_pagos,
    s.meses_asegurados,
    s.fecha_contratacion,
    s.fecha_vencimiento,
    c.nombre || ' ' || c.apellido AS cliente
FROM 
    SEGURO s
JOIN 
    TIPO_SEGURO ts ON s.id_tipo_seguro = ts.id_tipo_seguro
JOIN 
    CLIENTE c ON s.id_cliente = c.id_cliente
WHERE 
    s.fecha_vencimiento > SYSTIMESTAMP
ORDER BY 
    s.fecha_vencimiento;

CREATE OR REPLACE VIEW vw_inactive_insurances AS
SELECT 
    ts.nombre AS tipo_seguro,
    s.id_seguro,
    s.monto_asegurado,
    s.valor_seguro,
    s.cantidad_pagos,
    s.meses_asegurados,
    s.fecha_contratacion,
    s.fecha_vencimiento,
    c.nombre || ' ' || c.apellido AS cliente,
    CASE 
        WHEN s.fecha_vencimiento < SYSTIMESTAMP THEN 'Vencido'
        ELSE 'Inactivo por otro motivo'
    END AS estado
FROM 
    SEGURO s
JOIN 
    TIPO_SEGURO ts ON s.id_tipo_seguro = ts.id_tipo_seguro
JOIN 
    CLIENTE c ON s.id_cliente = c.id_cliente
WHERE 
    s.fecha_vencimiento <= SYSTIMESTAMP
ORDER BY 
    s.fecha_vencimiento DESC;
    

CREATE OR REPLACE VIEW vw_active_credit_cards AS
SELECT 
    tt.nombre AS tipo_tarjeta,
    t.id_tarjeta,
    t.numero_tarjeta,
    t.moneda,
    t.monto_limite,
    t.saldo_tarjeta,
    t.dia_corte,
    t.dia_pago,
    t.tasa_interes,
    t.fecha_vencimiento,
    c.nombre || ' ' || c.apellido AS cliente,
    CASE 
        WHEN t.fecha_vencimiento < SYSDATE THEN 'VENCIDA'
        WHEN t.saldo_tarjeta >= t.monto_limite THEN 'LÍMITE ALCANZADO'
        ELSE 'ACTIVA'
    END AS estado_tarjeta,
    (t.monto_limite - t.saldo_tarjeta) AS credito_disponible,
    TO_CHAR(ADD_MONTHS(t.fecha_vencimiento, -1), 'DD/MM/YYYY') AS fecha_proximo_corte,
    TO_CHAR(LAST_DAY(ADD_MONTHS(SYSDATE, 1)), 'DD/MM/YYYY') AS fecha_proximo_pago
FROM 
    TARJETA t
JOIN 
    TIPO_TARJETA tt ON t.id_tipo_tarjeta = tt.id_tipo_tarjeta
JOIN 
    CLIENTE c ON t.id_cliente = c.id_cliente
WHERE 
    t.fecha_vencimiento >= SYSDATE
    AND t.id_tipo = 'C' -- Filtra solo tarjetas de crédito
ORDER BY 
    t.fecha_vencimiento, c.apellido, c.nombre;


CREATE OR REPLACE VIEW vw_active_debit_cards AS
SELECT 
    tt.nombre AS tipo_tarjeta,
    t.id_tarjeta,
    t.numero_tarjeta,
    t.moneda,
    c.nombre || ' ' || c.apellido AS cliente,
    t.id_cuenta,
    cu.saldo_cuenta AS saldo_cuenta_asociada,
    t.fecha_vencimiento,
    TO_CHAR(t.created_at, 'DD/MM/YYYY') AS fecha_emision,
    (SELECT COUNT(*) 
     FROM MOVIMIENTO_TARJETA mt 
     WHERE mt.id_tarjeta = t.id_tarjeta
     AND mt.fecha_movimiento >= ADD_MONTHS(SYSDATE, -1)) AS movimientos_ultimo_mes
FROM 
    TARJETA t
JOIN 
    TIPO_TARJETA tt ON t.id_tipo_tarjeta = tt.id_tipo_tarjeta
JOIN 
    CLIENTE c ON t.id_cliente = c.id_cliente
LEFT JOIN 
    CUENTA cu ON t.id_cuenta = cu.id_cuenta
WHERE 
    t.fecha_vencimiento >= SYSDATE
    AND t.id_tipo = 'D' -- Filtra solo tarjetas de débito
ORDER BY 
    t.fecha_vencimiento, c.apellido, c.nombre;
    
CREATE OR REPLACE VIEW vw_transactions AS
SELECT 
    t.id_transaccion,
    tt.nombre AS tipo_transaccion,
    t.fecha_transaccion,
    t.valor,
    c.nombre || ' ' || c.apellido AS cliente,
    tc.nombre AS tipo_cuenta,
    CASE 
        WHEN t.id_cuenta_origen IS NOT NULL AND t.id_cuenta_destino IS NOT NULL 
            THEN 'Transferencia entre cuentas'
        WHEN t.id_cuenta_origen IS NOT NULL 
            THEN 'Débito desde cuenta'
        WHEN t.id_cuenta_destino IS NOT NULL 
            THEN 'Crédito a cuenta'
        ELSE 'Transacción directa'
    END AS descripcion_operacion,
    t.otros_detalles,
    t.id_cuenta_origen,
    t.id_cuenta_destino,
    t.id_tarjeta,
    t.id_cuenta
FROM 
    TRANSACCION t
JOIN 
    TIPO_TRANSACCION tt ON t.id_tipo_transaccion = tt.id_tipo_transaccion
JOIN 
    CLIENTE c ON t.id_cliente = c.id_cliente
LEFT JOIN 
    CUENTA cu ON t.id_cuenta = cu.id_cuenta
LEFT JOIN 
    TIPO_CUENTA tc ON cu.tipo_cuenta = tc.id_tipo_cuenta
WHERE 
    tt.nombre IN ('Débito', 'Crédito')
ORDER BY 
    t.fecha_transaccion DESC;
    
CREATE OR REPLACE VIEW vw_card_transactions AS
SELECT 
    -- Información de la tarjeta
    tar.id_tarjeta,
    tar.numero_tarjeta,
    CASE tar.id_tipo 
        WHEN 'C' THEN 'Crédito' 
        WHEN 'D' THEN 'Débito' 
    END AS tipo_tarjeta,
    tt.nombre AS categoria_tarjeta,
    
    -- Información de la transacción
    t.id_transaccion,
    ttran.nombre AS tipo_transaccion,
    t.fecha_transaccion,
    t.valor,
    CASE 
        WHEN mt.tipo = 'C' THEN 'Pago'
        WHEN mt.tipo = 'D' THEN 'Consumo'
        ELSE 'Otro'
    END AS naturaleza_operacion,
    
    -- Información del cliente
    c.nombre || ' ' || c.apellido AS cliente,
    c.numero_telefono,
    
    -- Información adicional
    t.otros_detalles,
    mt.descripcion AS detalle_movimiento,
    TO_CHAR(t.fecha_transaccion, 'DD/MM/YYYY HH24:MI') AS fecha_formateada
FROM 
    TRANSACCION t
JOIN 
    TARJETA tar ON t.id_tarjeta = tar.id_tarjeta
JOIN 
    TIPO_TARJETA tt ON tar.id_tipo_tarjeta = tt.id_tipo_tarjeta
JOIN 
    TIPO_TRANSACCION ttran ON t.id_tipo_transaccion = ttran.id_tipo_transaccion
JOIN 
    CLIENTE c ON t.id_cliente = c.id_cliente
LEFT JOIN 
    MOVIMIENTO_TARJETA mt ON t.id_transaccion = mt.id_movimiento
WHERE 
    t.id_tarjeta IS NOT NULL  -- Filtro clave para solo transacciones con tarjetas
ORDER BY 
    t.fecha_transaccion DESC;

